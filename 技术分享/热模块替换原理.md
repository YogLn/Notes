# HRM基本原理介绍



模块热替换(hot module replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新所有类型的模块，而无需完全刷新。HMR 主要功能是会**在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面**。那么Webpack在编译源码所产生的文件变化，替换模块实现运行时是怎样联系的呢？先看看我偷来的图

![image-20211220152536547](https://gitee.com/yogln/image-mac/raw/master/image-20211220152536547.png)

接下来开始 HMR 工作流程分析：

1. 当 Webpack（Watchman） 监听到项目中的文件/模块代码发生变化后，将变化通知 Webpack 中的构建工具（Packager）即 HMR Plugin；
2. 然后经过 HMR Plugin 处理后，将结果发送到应用程序（Application）的运行时框架（HMR Runtime）；
3. 最后由 HMR Runtime 将这些发生变化的文件/模块更新（新增/删除或替换）到模块系统中



# HRM完整原理和源码分析

你可能会想文件更新通知什么HMR Plugin？HMR Plugin 怎么发送更新到 HMR Runtime？等问题。我们接下来结合源码分析整个热更新的流程，先看看流程图（也是我偷的）。

![image-20211220153046535](https://gitee.com/yogln/image-mac/raw/master/image-20211220153046535.png)

红色字体黄色背景色部分为方法名称。

要了解上面工作原理，我们先理解图中这几个名称概念：

- [**Webpack-dev-server**](https://link.segmentfault.com/?enc=fkWTPd3hv7R5oxnuvOtogQ%3D%3D.DhQbUL7mMub%2BNy4RKttd4mlHUdhop5AG4q6pWZMQ6w2Sag6mWsAZNFsu74uqCrzz) ：一个服务器插件，相当于 express 服务器，启动一个 Web 服务，只适用于开发环境；
- [**Webpack-dev-middleware**](https://link.segmentfault.com/?enc=u4B88p1OzGxLybWGwjzmiw%3D%3D.ANs5Lmwb9y4zlw%2FieK%2Fo8K%2FhG2g6n9Sap05yGWSGCZivcwImdpjMZ1SIucyJTINX0svtbCUg361oTfYg747YEQ%3D%3D) ：一个 **Webpack-dev-server** 的中间件，作用简单总结为：通过watch mode，监听资源的变更，然后自动打包。
- [**Webpack-hot-middleware**](https://link.segmentfault.com/?enc=d1d4nJEnFqgUVMctm8zlkw%3D%3D.4ly169IOOCYPuCIiX5XnY2eFFnoq%2FA9cRB4l0YEBcql%2B6t%2Bx3AG4jkFErJM1Ykq9k7cZsZXF%2FYpl5TtB3FniWQ%3D%3D) ：结合 Webpack-dev-middleware 使用的中间件，它可以实现浏览器的无刷新更新，也就是 HMR；

我们来看看整个工作的流程

## 1. 监控代码变化，重新编译打包

首先根据 devServer 配置，使用 `npm start` 将启动 Webpack-dev-server 启动本地服务器并进入 Webpack 的 watch 模式，然后初始化 Webpack-dev-middleware ，在 Webpack-dev-middleware 中通过调用 `startWatch()` 方法对文件系统进行 watch：

```javascript
// webpack-dev-server\bin\webpack-dev-server.js
// 1.启动本地服务器 Line 386
server = new Server(compiler, options);

// webpack-dev-server\lib\Server.js
// 2.初始化 Webpack-dev-middleware Line 109
this.middleware = webpackDevMiddleware(compiler, Object.assign({}, options, wdmOptions));

// webpack-dev-middleware\lib\Shared.js
// 3.开始 watch 文件系统 Line 171
startWatch: function() {
    //...
    // start watching
    if(!options.lazy) {
        var watching = compiler.watch(options.watchOptions, share.handleCompilerCallback);
        context.watching = watching;
    }
    //...
}
share.startWatch();
// ...
```

当 `startWatch()` 方法执行后，便进入 watch 模式，若发现文件中代码发生修改，则根据配置文件**对模块重新编译打包**。



## 2.保存编译结果

Webpack 与 Webpack-dev-middleware 交互，Webpack-dev-middleware 调用 Webpack 的 API 对代码变化进行监控，并通知 Webpack 将重新编译的代码通过 JavaScript 对象**保存在内存中**。

我们会发现，在 `output.path` 指定的 `dist` 目录并没有保存编译结果的文件，这是为什么？

其实， Webpack 将编译结果保存在内存中，因为**访问内存中的代码比访问文件系统中的文件快**，这样可以减少代码写入文件的开销。

Webpack 能将代码保存到内存中，需要归功于 Webpack-dev-middleware 的 `memory-fs` 依赖库，它将原本 `outputFileSystem` 替换成了 `MemoryFileSystem` 的实例，便实现代码输出到内存中。其中部分源码如下：

```javascript
// webpack-dev-middleware\lib\Shared.js Line 108

// store our files in memory
var fs;
var isMemoryFs = !compiler.compilers && 
    compiler.outputFileSystem instanceof MemoryFileSystem;
if(isMemoryFs) {
    fs = compiler.outputFileSystem;
} else {
    fs = compiler.outputFileSystem = new MemoryFileSystem();
}
context.fs = fs;
```

上述代码先判断 `fileSystem` 是否是 `MemoryFileSystem` 的实例，若不是，则用 `MemoryFileSystem` 的实例替换 compiler 之前的 `outputFileSystem`。这样 bundle.js 文件代码就作为一个简单 JavaScript 对象保存在内存中，当浏览器请求 bundle.js 文件时，devServer 就直接去内存中找到上面保存的 JavaScript 对象并返回给浏览器端。



## 3.监控文件变化，刷新浏览器

Webpack-dev-server 开始监控文件变化，与第 1 步不同的是，这里并不是监控代码变化重新编译打包。
当我们在配置文件中配置了 [`devServer.watchContentBase`](https://link.segmentfault.com/?enc=hhyqGq%2BzCuyno1id17l6VQ%3D%3D.VQcAzQoY7MlVqXv3qroqniHLJacPOYV0JMrhYoraQQkocf3Y8%2FhkwQj4MmLM6dmNlaR%2BTnkoabJLDtiiqoA9ojlb4l3L5fxomOEfW0UOHCM%3D) 为 `true` ，Webpack-dev-server 会监听配置文件夹中静态文件的变化，发生变化时，通知浏览器端对应用进行**浏览器刷新**，这与 HMR 不一样。

```javascript
// webpack-dev-server\lib\Server.js
// 1. 读取参数 Line 385
if (options.watchContentBase) { defaultFeatures.push('watchContentBase'); }

// 2. 定义 _watch 方法 Line 697
Server.prototype._watch = function (watchPath) {
    // ...
  const watcher = chokidar.watch(watchPath, options).on('change', () => {
    this.sockWrite(this.sockets, 'content-changed');
  });

  this.contentBaseWatchers.push(watcher);
};

// 3. 执行 _watch() 监听文件变化 Line 339
watchContentBase: () => {
    if (/^(https?:)?\/\//.test(contentBase) || typeof contentBase === 'number') {
        throw new Error('Watching remote files is not supported.');
    } else if (Array.isArray(contentBase)) {
        contentBase.forEach((item) => {
            this._watch(item);
        });
    } else {
        this._watch(contentBase);
    }
}
```



## 4.建立 WS，同步编译阶段状态

这一步都是 Webpack-dev-server 中处理，主要通过 [sockjs](https://link.segmentfault.com/?enc=%2FrA2%2FCtfUTyhXBgA2wNfsw%3D%3D.rpRg%2Bnq4P%2FtjWx8upAB9dPnRcAYeLkAXA5esIlCqJnADUZAee4hRAy4%2Fz20%2BtaLx)（Webpack-dev-server 的依赖），在 Webpack-dev-server 的浏览器端（Client）和服务器端（Webpack-dev-middleware）之间**建立 WebSocket 长连接**。

然后将 Webpack 编译打包的各个阶段状态信息同步到浏览器端。其中有两个重要步骤：

- 发送状态

Webpack-dev-server 通过 Webpack API 监听 compile 的 `done` 事件，当 compile 完成后，Webpack-dev-server 通过 `_sendStats` 方法将编译后新模块的 hash 值用 socket 发送给浏览器端。

- 保存状态

浏览器端将`_sendStats` 发送过来的 `hash` 保存下来，**它将会用到后模块热更新**。

![image-20211220161117375](https://gitee.com/yogln/image-mac/raw/master/image-20211220161117375.png)



```javascript
// webpack-dev-server\lib\Server.js

// 1. 定义 _sendStats 方法 Line 685
// send stats to a socket or multiple sockets
Server.prototype._sendStats = function (sockets, stats, force) {
  //...
  this.sockWrite(sockets, 'hash', stats.hash);
};

// 2. 监听 done 事件 Line 86
compiler.plugin('done', (stats) => {
      // 将最新打包文件的 hash 值（stats.hash）作为参数传入 _sendStats()
    this._sendStats(this.sockets, stats.toJson(clientStats));
    this._stats = stats;
});

// webpack-dev-server\client\index.js
// 3. 保存 hash 值 Line 74
var onSocketMsg = {
  // ...
  hash: function hash(_hash) {
    currentHash = _hash;
  },
  // ...
}
socket(socketUrl, onSocketMsg);
```



## 5.浏览器端发布消息

当 `hash` 消息发送完成后，socket 还会发送一条 `ok` 的消息告知 Webpack-dev-server，由于客户端（Client）并不请求热更新代码，也不执行热更新模块操作，因此通过 `emit` 一个 `"webpackHotUpdate"` 消息，将工作转交回 Webpack。

```javascript
// webpack-dev-server\client\index.js
// 1. 处理 ok 消息 Line 135
var onSocketMsg = {
  // ...
  ok: function ok() {
      sendMsg('Ok');
      if (useWarningOverlay || useErrorOverlay) overlay.clear();
      if (initial) return initial = false; // eslint-disable-line no-return-assign
      reloadApp();
  },
  // ...
}

// 2. 处理刷新 APP Line 218
function reloadApp() {
  // ...
  if (_hot) {
    // 动态加载 emitter
    var hotEmitter = require('webpack/hot/emitter');
    hotEmitter.emit('webpackHotUpdate', currentHash);
    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage('webpackHotUpdate' + currentHash, '*');
    }
  }
  // ...
}
```



## 6.传递 hash 到 HMR

Webpack/hot/dev-server 监听浏览器端 `webpackHotUpdate` 消息，将新模块 hash 值传到客户端 HMR 核心中枢的 HotModuleReplacement.runtime ，并调用 `check` 方法检测更新，**判断是浏览器刷新还是模块热更新**。
如果是浏览器刷新的话，则没有后续步骤。这里也是判断热整体更新还是模块替换更新的关键。

```javascript
// webpack\hot\dev-server.js
// 1.监听 webpackHotUpdate Line 42
var hotEmitter = require("./emitter");
hotEmitter.on("webpackHotUpdate", function(currentHash) {
    lastHash = currentHash;
    if(!upToDate() && module.hot.status() === "idle") {
        log("info", "[HMR] Checking for updates on the server...");
        check();
    }
});

var check = function check() {
    module.hot.check(true).then(function(updatedModules) {
        if(!updatedModules) {
            // ...
            window.location.reload();// 浏览器刷新
            return;
        }
        if(!upToDate()) {
            check();
        }
    }).catch(function(err) { /*...*/});
};

// webpack\lib\HotModuleReplacement.runtime.js
// 3.调用 HotModuleReplacement.runtime 定义的 check 方法 Line 167
function hotCheck(apply) {
    if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
    hotApplyOnUpdate = apply;
    hotSetStatus("check");
    return hotDownloadManifest(hotRequestTimeout).then(function(update) {
                //...
    });
}
```



## 7.检测是否存在更新

当 HotModuleReplacement.runtime 调用 `check` 方法时，会调用 JsonpMainTemplate.runtime 中的 `hotDownloadUpdateChunk` （获取最新模块代码）和 `hotDownloadManifest` （获取是否有更新文件）两个方法，这两个方法的源码，在下一步展开。

```javascript
// webpack\lib\HotModuleReplacement.runtime.js
// 1.调用 HotModuleReplacement.runtime 定义 hotDownloadUpdateChunk 方法 Line 171
function hotCheck(apply) {
    if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
    hotApplyOnUpdate = apply;
    hotSetStatus("check");
    return hotDownloadManifest(hotRequestTimeout).then(function(update) {
                //...
        {
          // hotEnsureUpdateChunk 方法中会调用 hotDownloadUpdateChunk
          hotEnsureUpdateChunk(chunkId);
        }
    });
}
```

其中 `hotEnsureUpdateChunk` 方法中会调用 `hotDownloadUpdateChunk` ：

```javascript
// webpack\lib\HotModuleReplacement.runtime.js Line 215
function hotEnsureUpdateChunk(chunkId) {
    if(!hotAvailableFilesMap[chunkId]) {
        hotWaitingFilesMap[chunkId] = true;
    } else {
        hotRequestedFilesMap[chunkId] = true;
        hotWaitingFiles++;
        hotDownloadUpdateChunk(chunkId);
    }
}
```

## 8.请求更新最新模块代码

在 `hotDownloadManifest` 方法中，还会执行  `hotDownloadUpdateChunk` 方法，**通过 JSONP 请求最新的模块代码**，并将代码返回给 HMR runtime 。然后 HMR runtime 会将新代码进一步处理，**判断是浏览器刷新还是模块热更新**。

```javascript
// webpack\lib\JsonpMainTemplate.runtime.js
// hotDownloadManifest 定义 Line 12
function hotDownloadUpdateChunk(chunkId) {
        // 创建 script 标签，发起 JSONP 请求
    var head = document.getElementsByTagName("head")[0];
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.charset = "utf-8";
    script.src = $require$.p + $hotChunkFilename$;
    $crossOriginLoading$;
    head.appendChild(script);
}
```



## 9.更新模块和依赖引用

这一步是整个模块热更新（HMR）的核心步骤，通过 HMR runtime 的 `hotApply` 方法，移除过期模块和代码，并添加新的模块和代码实现热更新。从 `hotApply` 方法可以看出，模块热替换主要分三个阶段：

1. 找出过期模块 `outdatedModules` 和过期依赖 `outdatedDependencies` ；

```javascript
// webpack\lib\HotModuleReplacement.runtime.js
// 找出 outdatedModules 和 outdatedDependencies Line 342
function hotApply() { 
  // ...
  var outdatedDependencies = {};
  var outdatedModules = [];
  function getAffectedStuff(updateModuleId) {
    var outdatedModules = [updateModuleId];
    var outdatedDependencies = {};
    // ...
    return {
        type: "accepted",
        moduleId: updateModuleId,
        outdatedModules: outdatedModules,
        outdatedDependencies: outdatedDependencies
    };
    };
  function addAllToSet(a, b) {
      for (var i = 0; i < b.length; i++) {
          var item = b[i];
          if (a.indexOf(item) < 0)
              a.push(item);
      }
  }
  for(var id in hotUpdate) {
      if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
          // ... 省略多余代码
          if(hotUpdate[id]) {
              result = getAffectedStuff(moduleId);
          }
          if(doApply) {
              for(moduleId in result.outdatedDependencies) {
                 // 添加到 outdatedDependencies
                  addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
              }
          }
          if(doDispose) {
              // 添加到 outdatedModules
              addAllToSet(outdatedModules, [result.moduleId]);
              appliedUpdate[moduleId] = warnUnexpectedRequire;
          }
      }
  }
}
```

2. 从缓存中删除过期模块、依赖和所有子元素的引用；

```javascript
// webpack\lib\HotModuleReplacement.runtime.js
// 从缓存中删除过期模块、依赖和所有子元素的引用 Line 442
function hotApply() {
         // ...
    var idx;
    var queue = outdatedModules.slice();
    while(queue.length > 0) {
        moduleId = queue.pop();
        module = installedModules[moduleId];
        // ...
        // 移除缓存中的模块
        delete installedModules[moduleId];
        // 移除过期依赖中不需要使用的处理方法
        delete outdatedDependencies[moduleId];
        // 移除所有子元素的引用
        for(j = 0; j < module.children.length; j++) {
            var child = installedModules[module.children[j]];
            if(!child) continue;
            idx = child.parents.indexOf(moduleId);
            if(idx >= 0) {
                child.parents.splice(idx, 1);
            }
        }
    } 
        // 从模块子组件中删除过时的依赖项
        var dependency;
        var moduleOutdatedDependencies;
        for(moduleId in outdatedDependencies) {
            if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
                module = installedModules[moduleId];
                if(module) {
                    moduleOutdatedDependencies = outdatedDependencies[moduleId];
                    for(j = 0; j < moduleOutdatedDependencies.length; j++) {
                        dependency = moduleOutdatedDependencies[j];
                        idx = module.children.indexOf(dependency);
                        if(idx >= 0) module.children.splice(idx, 1);
                    }
                }
            }
        }
}
```

3. 将新模块代码添加到 modules 中，当下次调用 `__webpack_require__` (webpack 重写的 `require` 方法)方法的时候，就是获取到了新的模块代码了。

```javascript
// webpack\lib\HotModuleReplacement.runtime.js
// 将新模块代码添加到 modules 中 Line 501
function hotApply() {
         // ...
    for(moduleId in appliedUpdate) {
        if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
            modules[moduleId] = appliedUpdate[moduleId];
        }
    }
}
```

`hotApply` 方法执行之后，新代码已经替换旧代码，但是我们业务代码并不知道这些变化，因此需要通过 `accept`事件通知应用层使用新的模块进行“局部刷新”，我们在业务中是这么使用：

```javascript
if (module.hot) {
  module.hot.accept('./library.js', function() {
    // 使用更新过的 library 模块执行某些操作...
  })
}
```