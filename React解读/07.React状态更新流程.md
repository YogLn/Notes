# 流程概览

先看一下状态更新流程的整体流程图：

![image-20220126142837789](https://gitee.com/yogln/image-mac/raw/master/image-20220126142837789.png)

## 创建Update对象

在`React`中，有如下方法可以触发状态更新（排除`SSR`相关）：

- ReactDOM.render
- this.setState
- this.forceUpdate
- useState
- useReducer

这些方法调用的场景各不相同，他们是如何接入同一套**状态更新机制**呢？

答案是：每次状态更新都会创建一个保存**更新状态相关内容**的对象，我们叫他`Update`。在render阶段的beginWor中会根据Update计算新的state。

1. 我们看看`this.setState`，`this.setState`内调用`this.updater.enqueueSetState`

   ```js
   //ReactBaseClasses.js
   Component.prototype.setState = function (partialState, callback) {
     if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
       {
         throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
       }
     }
     this.updater.enqueueSetState(this, partialState, callback, 'setState');
   };
   ```

   ```js
   //ReactFiberClassComponent.old.js
   enqueueSetState(inst, payload, callback) {
     const fiber = getInstance(inst);//fiber实例
     const eventTime = requestEventTime();
     const suspenseConfig = requestCurrentSuspenseConfig();
     const lane = requestUpdateLane(fiber, suspenseConfig);//优先级
     const update = createUpdate(eventTime, lane, suspenseConfig);//创建update
     }
     enqueueUpdate(fiber, update);//将update加入updateQueue队列
     scheduleUpdateOnFiber(fiber, lane, eventTime);//调度update
   }
   ```

   ```js
   //ReactUpdateQueue.old.js
   export function enqueueUpdate<State>(fiber: Fiber, update: Update<State>) {
     const updateQueue = fiber.updateQueue;
     if (updateQueue === null) {
       return;
     }
     const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;
     const pending = sharedQueue.pending;
     if (pending === null) {
       update.next = update;//与自己形成环状链表
     } else {
       update.next = pending.next;//加入链表的结尾
       pending.next = update;
     }
     sharedQueue.pending = update;
   }
   ```

   ![image-20220126150852411](https://gitee.com/yogln/image-mac/raw/master/image-20220126150852411.png)

2. `this.forceUpdate`和`this.setState`一样，只是会让tag赋值`ForceUpdate`

   ```js
   //ReactBaseClasses.js
   Component.prototype.forceUpdate = function(callback) {
     this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
   };
   ```

   ```js
   //ReactFiberClassComponent.old.js
   enqueueForceUpdate(inst, callback) {
       const fiber = getInstance(inst);
       const eventTime = requestEventTime();
       const suspenseConfig = requestCurrentSuspenseConfig();
       const lane = requestUpdateLane(fiber, suspenseConfig);
      
       const update = createUpdate(eventTime, lane, suspenseConfig);
          
       //tag赋值ForceUpdate
       update.tag = ForceUpdate;
          
       if (callback !== undefined && callback !== null) {
         update.callback = callback;
       }
          
       enqueueUpdate(fiber, update);
       scheduleUpdateOnFiber(fiber, lane, eventTime);
      
     },
   };
   ```

   如果标记ForceUpdate，render阶段组件更新会根据`checkHasForceUpdateAfterProcessing`和`checkShouldComponentUpdate`来判断

   - checkHasForceUpdateAfterProcessing：内部会判断本次更新的`Update`是否为`ForceUpdate`。即如果本次更新的`Update`中存在`tag`为`ForceUpdate`，则返回`true`。
   - checkShouldComponentUpdate：内部会调用`shouldComponentUpdate`方法。以及当该`ClassComponent`为`PureComponent`时会浅比较`state`与`props`。

   如果Update的tag是ForceUpdate，则checkHasForceUpdateAfterProcessing为true，当组件是PureComponent时，checkShouldComponentUpdate会浅比较state和props。

   **某次更新含有tag为ForceUpdate的Update，那么当前ClassComponent不会受其他性能优化手段（shouldComponentUpdate|PureComponent）影响，一定会更新。**

## 从fiber到root

调用`markUpdateLaneFromFiberToRoot`方法,可以从触发状态更新的fiber得到rootFiber（因为render阶段是从rootFiber开始向下遍历），由于不同更新优先级不尽相同，所以过程中还会更新遍历到的fiber的优先级。

## 调度更新

现在我们拥有一个`rootFiber`，该`rootFiber`对应的Fiber树中某个Fiber节点包含一个`Update`。

接下来通知`Scheduler`根据**更新**的优先级，决定以**同步**还是**异步**的方式调度本次更新。

这里调用的方法是`ensureRootIsScheduled`。下面是该方法的一段核心代码：

```js
if (newCallbackPriority === SyncLanePriority) {
  // 任务已经过期，需要同步执行render阶段
  newCallbackNode = scheduleSyncCallback(
    performSyncWorkOnRoot.bind(null, root)
  );
} else {
  // 根据任务优先级异步执行render阶段
  var schedulerPriorityLevel = lanePriorityToSchedulerPriority(
    newCallbackPriority
  );
  newCallbackNode = scheduleCallback(
    schedulerPriorityLevel,
    performConcurrentWorkOnRoot.bind(null, root)
  );
}
```

其中，`scheduleCallback`和`scheduleSyncCallback`会调用`Scheduler`提供的调度方法根据`优先级`调度回调函数执行。

```js
performSyncWorkOnRoot.bind(null, root);
performConcurrentWorkOnRoot.bind(null, root);
```

从这里调度的回调函数连接上了`render阶段`。

# update

## update分类

我们将可以触发更新的方法所隶属的组件分类：

- ReactDOM.render —— HostRoot
- this.setState —— ClassComponent
- this.forceUpdate —— ClassComponent
- useState —— FunctionComponent
- useReducer —— FunctionComponent

可以看到，一共三种组件（`HostRoot` | `ClassComponent` | `FunctionComponent`）可以触发更新。

由于不同类型组件工作方式不同，所以存在两种不同结构的`Update`，其中`ClassComponent`与`HostRoot`共用一套`Update`结构，`FunctionComponent`单独使用一种`Update`结构。虽然他们的结构不同，但是他们工作机制与工作流程大体相同。

## update结构

`ClassComponent`与`HostRoot`（即`rootFiber.tag`对应类型）共用同一种`Update结构`:

```js
export function createUpdate(eventTime: number, lane: Lane): Update<*> {
  const update: Update<*> = {
    eventTime, //任务时间，通过performance.now()获取的毫秒数。由于该字段在未来会重构
    lane, //优先级
    tag: UpdateState, //更新的类型，例如UpdateState、ReplaceState
    payload: null, //ClassComponent的payload是setState第一个参数，HostRoot的payload是ReactDOM.render的第一个参数
    callback: null, //setState的第二个参数
    next: null, //连接下一个Update形成一个链表，例如同时触发多个setState时会形成多个Update，然后用next 连接
  };
  return update;
}
```

## Update与Fiber的联系

`Update`存在一个连接其他`Update`形成链表的字段`next`。类似`Fiber节点`组成`Fiber树`，`Fiber节点`上的多个`Update`会组成链表并被包含在`fiber.updateQueue`中。

有的fiber节点可能会存在多个Update，这也是很常见的，举很简单的例子：

```js
onClick() {
  this.setState({
    a: 1
  })

  this.setState({
    b: 2
  })
}
```

在一个`ClassComponent`中触发`this.onClick`方法，方法内部调用了两次`this.setState`。这会在该`fiber`中产生两个`Update`。

## updateQueue

对于`HostRoot`或者`ClassComponent`会在mount的时候使用`initializeUpdateQueue`创建`updateQueue`，然后将updateQueue挂载到fiber节点上

```js
export function initializeUpdateQueue<State>(fiber: Fiber): void {
  const queue: UpdateQueue<State> = {
    baseState: fiber.memoizedState, // 本次更新前该Fiber节点的state，Update基于该state计算更新后的state
    firstBaseUpdate: null,// update形成的链表的头
    lastBaseUpdate: null,// update形成的链表的尾
    shared: {
      //新产生的update会以单向环状链表保存在shared.pending上，计算state的时候会剪开这个环状链表，并且链接在lastBaseUpdate后
      pending: null,
    },
    effects: null,// calback不为null的update
  };
  fiber.updateQueue = queue;
}
```

# 从fiber到root

在`markUpdateLaneFromFiberToRoot`函数中会从触发更新的节点开始向上遍历到`rootFiber`，遍历的过程会处理节点的优先级。

```js
function markUpdateLaneFromFiberToRoot(
  sourceFiber: Fiber,
  lane: Lane,
): FiberRoot | null {
  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
  let alternate = sourceFiber.alternate;
  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, lane);
  }
  let node = sourceFiber;
  let parent = sourceFiber.return;
  while (parent !== null) {//从触发更新的节点开始向上遍历到rootFiber
    parent.childLanes = mergeLanes(parent.childLanes, lane);//合并childLanes优先级
    alternate = parent.alternate;
    if (alternate !== null) {
      alternate.childLanes = mergeLanes(alternate.childLanes, lane);
    } else {
    }
    node = parent;
    parent = parent.return;
  }
  if (node.tag === HostRoot) {
    const root: FiberRoot = node.stateNode;
    return root;
  } else {
    return null;
  }
}
```

不同节点更新的优先级不同，参与计算的节点也不同，优先级低的可能不会参与计算。

# 状态更新

`classComponent`状态计算发生在`processUpdateQueue`函数中，涉及很多链表操作，看图更加直白

- 初始时fiber.updateQueue单链表上有firstBaseUpdate（update1）和lastBaseUpdate（update2），以next连接
- fiber.updateQueue.shared环状链表上有update3和update4，以next连接互相连接
- 计算state时，先将fiber.updateQueue.shared环状链表‘剪开’，形成单链表，连接在fiber.updateQueue后面形成baseUpdate
- 然后遍历按这条链表，根据baseState计算出memoizedState

![image-20220126171126798](https://gitee.com/yogln/image-mac/raw/master/image-20220126171126798.png)

# 带优先级的状态更新

优先级更高的任务，比如用户出发的事件，数据请求，同步执行的代码等

- 通过ReactDOM.render创建的应用没有优先级的概念

- 在concurrent模式下，优先级是由Scheduler来调度的，这里我们只关心状态计算时的优先级排序，也就是在函数processUpdateQueue中发生的计算

  例如初始时有c1-c4四个update，其中c1和c3为高优先级

  1. 在第一次render的时候，低优先级的update会跳过，所以只有c1和c3加入状态的计算
  2. 在第二次render的时候，会以第一次中跳过的update（c2）之前的update（c1）作为`baseState`，跳过的update和之后的update（c2，c3，c4）作为`baseUpdate`重新计算

![image-20220126183800275](https://gitee.com/yogln/image-mac/raw/master/image-20220126183800275.png)

计算状态的函数：

```js
export function processUpdateQueue<State>(
  workInProgress: Fiber,
  props: any,
  instance: any,
  renderLanes: Lanes,
): void {
  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);
  hasForceUpdate = false;

  let firstBaseUpdate = queue.firstBaseUpdate;//updateQueue的第一个Update
  let lastBaseUpdate = queue.lastBaseUpdate;//updateQueue的最后一个Update
  let pendingQueue = queue.shared.pending;//未计算的pendingQueue

  if (pendingQueue !== null) {
    queue.shared.pending = null;
    const lastPendingUpdate = pendingQueue;//未计算的ppendingQueue的最后一个update
    const firstPendingUpdate = lastPendingUpdate.next;//未计算的pendingQueue的第一个update
    lastPendingUpdate.next = null;//剪开环状链表
    if (lastBaseUpdate === null) {//将pendingQueue加入到updateQueue
      firstBaseUpdate = firstPendingUpdate;
    } else {
      lastBaseUpdate.next = firstPendingUpdate;
    }
    lastBaseUpdate = lastPendingUpdate;

    const current = workInProgress.alternate;//current上做同样的操作
    if (current !== null) {
      const currentQueue: UpdateQueue<State> = (current.updateQueue: any);
      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;
      if (currentLastBaseUpdate !== lastBaseUpdate) {
        if (currentLastBaseUpdate === null) {
          currentQueue.firstBaseUpdate = firstPendingUpdate;
        } else {
          currentLastBaseUpdate.next = firstPendingUpdate;
        }
        currentQueue.lastBaseUpdate = lastPendingUpdate;
      }
    }
  }

  if (firstBaseUpdate !== null) {
    let newState = queue.baseState;

    let newLanes = NoLanes;

    let newBaseState = null;
    let newFirstBaseUpdate = null;
    let newLastBaseUpdate = null;

    let update = firstBaseUpdate;
    do {
      const updateLane = update.lane;
      const updateEventTime = update.eventTime;
      if (!isSubsetOfLanes(renderLanes, updateLane)) {//判断优先级是够足够
        const clone: Update<State> = {//优先级不够 跳过当前update
          eventTime: updateEventTime,
          lane: updateLane,

          tag: update.tag,
          payload: update.payload,
          callback: update.callback,

          next: null,
        };
        if (newLastBaseUpdate === null) {//保存跳过的update
          newFirstBaseUpdate = newLastBaseUpdate = clone;
          newBaseState = newState;
        } else {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        newLanes = mergeLanes(newLanes, updateLane);
      } else {
        //直到newLastBaseUpdate为null才不会计算，防止updateQueue没计算完
        if (newLastBaseUpdate !== null) {
          const clone: Update<State> = {
            eventTime: updateEventTime,
            lane: NoLane,

            tag: update.tag,
            payload: update.payload,
            callback: update.callback,

            next: null,
          };
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }

        newState = getStateFromUpdate(//根据updateQueue计算state
          workInProgress,
          queue,
          update,
          newState,
          props,
          instance,
        );
        const callback = update.callback;
        if (callback !== null) {
          workInProgress.flags |= Callback;//Callback flag
          const effects = queue.effects;
          if (effects === null) {
            queue.effects = [update];
          } else {
            effects.push(update);
          }
        }
      }
      update = update.next;//下一个update
      if (update === null) {//重置updateQueue
        pendingQueue = queue.shared.pending;
        if (pendingQueue === null) {
          break;
        } else {
          const lastPendingUpdate = pendingQueue;

          const firstPendingUpdate = ((lastPendingUpdate.next: any): Update<State>);
          lastPendingUpdate.next = null;
          update = firstPendingUpdate;
          queue.lastBaseUpdate = lastPendingUpdate;
          queue.shared.pending = null;
        }
      }
    } while (true);

    if (newLastBaseUpdate === null) {
      newBaseState = newState;
    }

    queue.baseState = ((newBaseState: any): State);//新的state
    queue.firstBaseUpdate = newFirstBaseUpdate;//新的第一个update
    queue.lastBaseUpdate = newLastBaseUpdate;//新的最后一个update

    markSkippedUpdateLanes(newLanes);
    workInProgress.lanes = newLanes;
    workInProgress.memoizedState = newState;
  }

	//...
}
```

