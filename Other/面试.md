

##  网络模型

- OSI 和TCP/IP 的对应关系和协议

![img](https://pic1.zhimg.com/80/v2-2d62ba265be486cb94ab531912aa3b9c_720w.jpg)

OSI模型各层的基本作用

![img](https://pic2.zhimg.com/80/v2-436927a69a3574532059a78623d3095d_720w.jpg)

## 一个HTTP请求的分层解析流程

1.解析域名，交互只认IP地址，先查看浏览器中是否有对应域名的DNS缓存，如果有就直接拿到IP，如果没有就去找本地ｈｏｓｔ配置里面是否有配置这个域名对应的IP，**如果也没有就会发起DNS请求**，本机host文件里面没有就去根服务器里面查，获取对应的IP,**在应用层就已经获得了IP了**

2.**发起DNS请求之后应用层**会构造一个DNS请求报文然后应**用层会调用传输层UDP相关协议**，即调用传输层API之后会在DNS报文上加上一个UDP请求头，**然后传输层会交给网络层**，网络层会在UDP的基础上再加一个IP的请求头，**然后网络层会把其交给数据链路层**，数据链路层会进行一个二层的寻址，会把自己的Mark加上去**再通过物理层传到路由器**，路由器由三层构成分别是网络层、数据链路层、物理层，**传到路由器之后从物理层开始一层一层解析到网络层**之后会传到运营商的网络接口最后会找到对应域名的IP地址

**总的来说要获得一个域名的IP那么是从HTTP协议发起请求加上TCP协议参数再加上IP协议的参数和Mark投发送到路由器中然后获得对应的IP地址**

![preview](https://pic3.zhimg.com/v2-80430dbb37a1e42315a77e30448b34b2_r.jpg)

## DNS解析过程

- 查询浏览器中是否有这个域名对应IP的缓存
- 如果浏览器中没有就去本地host文件中去查询是否有设置对应域名的IP
- 如果本地DNS解析器没有就会去查找本地DNS服务器尝试解析
- 如果本地DNS服务器解析失败就会去根服务器中(.com)去解析直到找到域名对应该得主机

## HTTP 协议

**HTTP协议是超文本传输协议,其传输是由UDP(传输层)负责的**,**是一种无状态的,以请求/应答方式运行的协议,**它使用可扩展的语义和自描述消息格式,与基于网络的超文本信息系统灵活的互动

HTTP/1.1 主要解决了HTTP 1.0的网络性能的问题，以及增加了一些新的东西：

- 可以设置 `keepalive` 来让HTTP重用TCP链接，重用TCP链接可以省了每次请求都要在广域网上进行的TCP的三次握手的巨大开销。这是所谓的“**HTTP 长链接**” 或是 “**请求响应式的HTTP 持久链接**”。英文叫 HTTP Persistent connection.
- 然后支持pipeline网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（注：非幂等的POST 方法或是有依赖的请求是不能被pipeline化的）
- 支持 Chunked Responses ，也就是说，在Response的时候，不必说明 `Content-Length` 这样，客户端就不能断连接，直到收到服务端的EOF标识。这种技术又叫 “**服务端Push模型**”，或是 “**服务端Push式的HTTP 持久链接**”
- 还增加了 cache control 机制。
- 协议头注增加了 Language, Encoding, Type 等等头，让客户端可以跟服务器端进行更多的协商。
- 还正式加入了一个很重要的头—— `HOST`这样的话，服务器就知道你要请求哪个网站了。因为可以有多个域名解析到同一个IP上，要区分用户是请求的哪个域名，就需要在HTTP的协议中加入域名的信息，而不是被DNS转换过的IP信息。
- 正式加入了 `OPTIONS` 方法，其主要用于 [CORS – Cross Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) 应用。

HTTP/1.1应该分成两个时代，一个是2014年前，一个是2014年后，因为2014年HTTP/1.1有了一组RFC（[7230](https://tools.ietf.org/html/rfc7230) /[7231](https://tools.ietf.org/html/rfc7231)/[7232](https://tools.ietf.org/html/rfc7232)/[7233](https://tools.ietf.org/html/rfc7233)/[7234](https://tools.ietf.org/html/rfc7234)/[7235](https://tools.ietf.org/html/rfc7235)），这组RFC又叫“HTTP/2 预览版”。其中影响HTTP发展的是两个大的需求：

- 一个需要是加大了HTTP的安全性，这样就可以让HTTP应用得广泛，比如，使用TLS协议。

- 另一个是让HTTP可以支持更多的应用，在HTTP/1.1 下，HTTP已经支持四种网络协议：

  - 传统的短链接。

  - 可重用TCP的的长链接模型。

  - 服务端push的模型。

  - WebSocket模型。

    

  - ![img](https://img-blog.csdnimg.cn/20200922123003302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center)

  - QUIC协议 存在的意义在于解决 TCP 协议的一些无法解决的痛点

    多次握手：TCP 协议需要三次握手建立连接，而如果需要 TLS 证书的交换，那么则需要更多次的握手才能建立可靠连接，这在如今长肥网络的趋势下是一个巨大的痛点
    队头阻塞：TCP 协议下，如果出现丢包，则一条连接将一直被阻塞等待该包的重传，即使后来的数据包可以被缓存，但也无法被提交给应用层去处理。
    无法判断一个 ACK 是重传包的 ACK 还是原本包的 ACK：比如 一个包 seq=1, 超时重传的包同样是 seq=1，这样在收到一个 ack=1 之后，我们无法判断这个 ack 是对之前的包的 ack 还是对重传包的 ack，这会导致我们对 RTT 的估计出现误差，无法提供更准确的拥塞控制
    无法进行连接迁移：一条连接由一个四元组标识，在当今移动互联网的时代，如果一台手机从一个 wifi 环境切换到另一个 wifi 环境，ip 发生变化，那么连接必须重新建立，inflight 的包全部丢失。
    现在我们给出一个 QUIC 协议的 Overview

    更好的连接建立方式
    更好的拥塞控制
    没有队头阻塞的多路复用
    前向纠错
    连接迁移

#### 1、通用头部

通用头域包含请求和响应消息都支持的头域。

```
Request URL:请求的URL地址
Request Method: 请求方法，get/post/put/……
Status Code：状态码，200 为请求成功
Remote Address：路由地址
```

#### 2、请求头部

```
 1） Accept：  告诉WEB服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型；
 2）Accept-Charset：  浏览器申明自己接收的字符集
 Accept-Encoding：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法  （gzip，deflate）
 3）Accept-Language：  浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。
 4）Authorization：  当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，该头部来回应自己的身份验证信息给WEB服务器。
 5）Connection：表示是否需要持久连接。close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，
 不要等待本次连接的后续请求了）。keep-alive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。
 6）Referer：发送请求页面URL。浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。
 7）User-Agent: 浏览器表明自己的身份（是哪种浏览器）。
 8）Host： 发送请求页面所在域。
 9）Cache-Control：浏览器应遵循的缓存机制。
        no-cache（不要缓存的实体，要求现在从WEB服务器去取）
        max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象） 
        max-stale：（可以接受过去的对象，但是过期时间必须小于 max-stale 值）  
        min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象）
 10）Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。
 11）Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。
 12）Form：一种请求头标，给定控制用户代理的人工用户的电子邮件地址。
 13）Cookie：这是最重要的请求头信息之一
```

#### 3、响应头部

```
1）Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。
2）Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。
3） Cache-Control：服务器应遵循的缓存机制。
      public(可以用 Cached 内容回应任何用户)
      private（只能用缓存内容回应先前请求该内容的那个用户）
      no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端） 
      max-age：（本响应包含的对象的过期时间）  
      ALL:  no-store（不允许缓存）  
4） Connection： 是否需要持久连接
      close（连接已经关闭）。
      keepalive（连接保持着，在等待本次连接的后续请求）。
      Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300
5）Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。 例如：Content-Encoding：gzip 
6）Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。
7）Content-Length：WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012
8）Content-Range：WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022
9）Content-Type：WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml
10）Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。
11） Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。
12） Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。
13）Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。
14）Server: WEB 服务器表明自己是什么软件及版本等信息。
15）Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。
```



### HTTP请求完整的过程

![image-20210115173019802](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210115173019802.png)

- 解析IP,先从浏览器缓存中检查是否有该域名对应的IP没有就从本地host文件去找如果还没有就发起DNS请求获取ip
- 网络请求:TCP三次握手，向IP地址发送HTTP请求，服务器处理HTTP请求，返回响应结果，TCP四次挥手，浏览器解析HTML，浏览器布局渲染

### 现代浏览器在与服务器建立了一个TCP连接后是否会在一个HTTP请求完成后断开?什么情况下会断开?

在HTTP1.0中一个服务器在发送完一个HTTP响应之后会断开TCP连接，但是这样每次请求都会重新建立和 断开TCP连接代价过大。

HTTP1.1把connection头写进标准，并且默认开启持久连接，除非请求中写明 Connection:close那么浏览器和服务器之间是会维持一段时间的TCP连接不会一个请求结束就断掉

**所以在现代浏览器中建立一个TCP连接后可以对应多个HTTP连接，也不会出现一个HTTP请求之后就断开的情况，而是会维持一段时间**

### 一个TCP连接中HTTP请求可以一起发送吗?(HTTP2.0和HTTP1.1的区别)

HTTP1.1存在一个问题，单个TCP连接在同一时刻只能处理一个请求。

但是在HTTP2.0提供了Multiplexing多路传输特性，可以在一个TCP连接中同时完成多个HTTP请求，**所以在HTTP2.0之后多个HTTP请求可以在同一个TCP连接中并行进行**

### 浏览器对同一host建立TCP连接的数量有没有限制?

如果是HTTP1.1还没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办?肯定不能只开一个TCP连接顺序下载，也不能有多少照片就开多少连接电脑会承受不住，**所以在HTTP2.0开始允许多路传输但是有限制，谷歌浏览器最多允许对同一个host建立六个TCP连接。**

### HTTP状态码?

- 1xx开头得都是 消息类状态码，代表请求已被接受需要哦继续处理
- 2xx开头的表示请求已经成功被服务器接收、理解并接收，最经典的就是200代表成功
- 3xx开头的 状态码表示重定向
- 4xx开头的状态码表示请求错误，比如400表示请求参数有错误，401表示权限不足，403表示服务器已经收到请求但是拒绝执行，404表示请求失败，请求所希望获得的资源在服务器上未发现，405表示请求方法错误
- 5xx开头的状态码表示服务器错误，比如500表示服务器遇到了一个错误无法完成完成请求，一般是后端代码出现错误，501表示服务器不支持当前请求所需要的某个功能，502表示网络错误服务器无响应,503表示服务器不具备完成请求的功能

### 为什么DNS请求域名解析要用UDP而不用TCP?

因为UDP快只需要一个请求一个应答就好了，而使用TCP的DNS协议要三次握手四次挥手

### 为什么区域复制要用TCP而不用UDP?

因为TCP的可靠性好，复制的东西要 保证可靠性

### get和post请求分别是什么含义?

get请求获取资源,post请求传输实体文本

### get和post的区别?

- get方法用信息获取，它是安全的，而post方法是用于修改服务器上资源的请求
- get请求的数据会附在URL后面而post请求提交的数据则是放在HTTP报文实体的主体里，所以post方法的安全性比get更高
- get方法传输的数据一般限制在2KB，而post方法对于数据大小是无限制的,真正影响到数据大小的是服务器处理程序的能力

### http报文头部有几种类型?

get/post/put/delete/head/options等等一共九种

## TCP协议

TCP协议是面向链接的，可靠的，基于字节流的传输层通信协议

特点:

- 基于连接的：数据传输之前需要建立连接
- 全双工的:双向传输
- 字节流:不限制数据大小，打包成报文段，保证有序接收，重复报文自动丢弃
- 流量缓冲:解决双方处理能力的不匹配
- 可靠的传输服务:保证可达，丢包时通过重发机制实现可靠性
- 拥塞控制:防止网络出现恶行拥塞

### TCP连接管理

TCP连接:四元组(源地址，源端口，目的地址，目的端口)

TCP报文：

### TCP三次握手:

![img](https://coolshell.cn/wp-content/uploads/2014/05/tcp_open_close.jpg)

左边是客户端右边是服务器

首先客户端想要建立连接就发送一个连接报文和随机序列号(x)到服务器SYN,seq=x然后客户端进入SYN-SENT发送状态，服务器收到客户端的连接报文之后应答回客户端发送一个ACK,ack=x+1(表示应答了seq=x的连接请求)和一个连接请求SYN,seq=y并进入等待应带状态,客户端收到来自服务器的ACK,ack=x+1之后进入ESTABLISHED(连接状态)，然后客户端应答服务器的连接请求返回一个ACK,ack=y+1回服务器，服务器收到之后进入到ESTABLISHED(连接状态)

TCP三次握手时操作系统内核情况:

![image-20210117010356930](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210117010356930.png)

在接收到SYN报文时会将其放入SYN队列当中然后立刻返回一个SYN/ACK然后进入等待状态，等待接收到对应的ACK后进入ACCEPT队列中Socket Api就能成功拿到连接即代表进入了ESTABLISHED(建立连接)状态

### TCP为什么是三次握手而不是两次或者四次握手?

**TCP是全双工的，即客户端再给服务器发送信息的同时服务器也可以给客户端发送信息，假设A和B是通信双方，握手实际上就是通信，发一次信息就是进行一次握手**

- **第一次握手:A给B打电话说，你可以听到我说话吗?**
- **第二次握手:B收到了A的信息然后对A说:我可以听得到你说话，你可以听得到我说话吗?**
- **第三次握手:A收到了B的信息，然后说可以，我要给你发信息拉！**

**在三次握手之后A和B都能确定这么一件事我说的话你能听到，你说的话我能听到。这样就可以开始正常通信了**

**如果两次那么B无法确定B的信息A是否能收到，所以如果B说话后面A都可能听不到会出现问题**

**如果四次，那么久造成了浪费，因为三次结束之后就已经可以保证A和B之间信息互通均可收到**

### TCP四次挥手:

![image-20210117235836565](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210117235836565.png)

客户端发送一个FIN报文然后客户端进入等待关闭状态，服务器端收到来自客户端的FIN报文之后会立刻返回一个ACK告诉客户端已经收到了FIN报文，然是需要稍作等候（慢慢处理成能够关闭不带来数据丢失的状态）然后服务器端再发送一个FIN报文给客户端告诉客户端服务器已经准备好释放连接了，客户端接收到来自服务器端的FIN报文之后立刻返回一个ACK给服务器端告诉服务器端已经收到服务器端的FIN，然后需要等待一个报文来回的时间2MSL之后客户端最终进入CLOSE状态

**为什么最后要等待2MSL后释放连接:**

- **防止报文丢失，导致服务端重复发送FIN**
- **防止滞留在网络中的报文对新建立的连接造成数据扰乱**

### TCP四次挥手为什么不能是三次挥手呢?

**因为第一次挥手表示客户端的数据已经发送完成，但是这个时候服务端的数据还没有发送完成，所以先发送一个ack给客户端表示收到，等服务端的数据发送完成之后再发送一个fin给客户端表示服务端的数据也发送完成了，最后客户端再发送一个ack表示收到**

- **就比如工厂下班，A对B说下班了(fin)**
- **B说好啊(ack)，但是得等我把手上的活做完，先等等我**
- **B做完手上的活之后给A说我做完了(fin)**
- **A说知道了(ack)，一起下班吧**

### 半关闭、半连接、半打开

半关闭：当TCP连接中A向B发送FIN请求关闭，另一端B回应ACK之后并没有立即发送FIN 给A此时A就处于半关闭状态可以接受B发送的数据但是不能向B发送数据

半连接:发生在TCP三次握手中，如果A向B发起连接，B也正常情况响应了，但是A不进行第三次握手这就是半连接(两次握手)

半打开：如果一方关闭或者异常关闭而另一方不知情这样的连接称之为半打开

### TCP是一个字节流的协议

**TCP把应用交付的数据仅仅看成是一连串无结构的字节流，TCP并不知道字节流的含义，TCP并不关心应用程序一次将多大的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥堵的程度来决定一个报文段应该包含多少个字节，并且拥有报文去重的能力**

### 数据可靠性传输

![image-20210118001647879](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118001647879.png)

即一个报文发送等待一个ack的接收

重传机制:如果传输过程中数据有丢失

#### 1.ack报文丢失

客户端在一定时间的等待之后没有收到服务端的ack就会任务ack丢失了就会进行一个报文的重传直到收到ack

#### 2.请求报文丢失

和上面的一样客户端在一定时间收不到ack就会重新发送报文，直到收到ack

#### 滑动窗口协议与累计确认(延时ack)

滑动窗口大小通过tcp三次握手和对端协商且受网络状况影响，

它是一次发送一批报文，如上图加入一次性一批发送了5个报文，但是我们只收到了1245的ack其中3的ack丢失了，那么我们只能算从开头连续的最长报文即12，剩下的345下次都要重传

**延时ack：ack的发送有延时机制，如果连续收到两个报文并不一定需要回复两个ack，只需要回复最后一次到达的报文就可以了，用于降低网络流量**

### TCP可靠传输怎么实现?

**一个报文对应一个ack**

**重传机制**:发送之后一定时间内没有收到ack造成的超时现象就会重新发送报文直到收到ack位置，不管是报文丢失还是ack丢失都会造成超时现象触发重传机制

### TCP/UDP的区别

- TCP提供得是面向连接得、可靠得数据流传输，UDP提供是非面向连接得、不可靠数据流传输
- TCP提供可靠得服务，通过TCP连接传送得数据可靠，UDP尽最大努力交付，即不可靠
- TCP面向字节流，UDP面向报文
- TCP连接只能是点对点，UDP支持一对一，一对多，多对一和多对多得通信
- UDP具有较好的实时性，工作效率比TCP高
- TCP对系统资源要求较多，UDP对系统资源要求较少
- TCP是可靠得全双工，UDP是不可靠信道

### TCP的拥塞控制

在某段时间若对网络中某一资源得需求超过了该资源能提供得部分网络就会拥塞，发送方发送一些报文时，如果发送方没有在时间间隔内收到接收方的确认报文段时，则就可以认为网络出现了拥塞

TCP四种拥塞控制算法:

- 慢开始：如果以开始将大量数据注入网络中可能会出现网络的拥塞，所以以开始发送一小部分试探网络的状况，如果状况良好，发送方每发送一次文段都唔那个正确的接受确认报文段
- 拥塞避免:为慢开始设置一个门限，当小于这个门限就使用慢开始，如果大于这个门限就使用拥塞控制算法
- 快重传
- 快回复

## HTTPS协议

HTTPS协议相对于HTTP的"裸奔"似的协议不同，HTTP随时都能被截取被篡改或者被拦截，但是HTTPS协议是一种安全的协议，他并没有改变HTTP协议本身只是在HTTP和TCP层之间增加了一个SSL层，SSL一般就是加密算法

加密算法 有对称密钥加密算法和非对称密钥加密算法

### 对称密钥加密算法

编码和解码使用相同的密钥的算法比如**AES，SHA256**等等

### 非对称密钥加密算法

他拥有两个密钥一个叫公钥一个叫私钥，两个密钥是不同的，公钥可以公开给任何人使用，而私钥必须严格保密，服务器秘密保管私钥，在网上任意分发公钥，想要登录网站只需要使用公钥加密就行，但是通常 需要大量的数学运算会比较慢，常见的有**RSA，DSA，ECDSA**

### 为什么有时候刷新页面不需要重新建立SSL连接?

**TCP连接有时候会在服务器端维持一段时间，TCP不需要 重新连接SSL自然也会用之前的**



## 异常/中断、核心态/用户态

**操作系统内核工作在核心态，用户程序工作在用户态。系统不允许 用户程序实现核心态的功能，而它们又必须使用这些功能。因此需要在核心态建立一些门，以便实现从用户态进入核心态**，**在实际操作系统中CPU运行上层程序时唯一能进入这些门的途径就是通过中断或异常**

中断:**也称外中断，指来自CPU执行指令以外的事件的发生**，

异常:**也称内中断，指源自CPU执行指令内部的事件**

## 进程、线程、协程

进程:操作系统会以进程为单位分配系统资源(CPU时间片、内存等)，进程是资源分配的最小单位，进程拥有自己独立的地址空间

进程间通信: 管道、消息队列、信号量、共享内存

线程:是系统调度(CPU调度)执行的最小单位,进程即程序运行会生成进程而线程即程序在不同的数据集上运行

线程之间通信:

同步(syn)、while轮询方式(一直等待是否有通信信息到来)、wait/notify机制

进程和线程的区别:

- 线程是调度和分配的基本单位，进程作为分配资源的基本单位
- 并发性:不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行
- 进程拥有独立的空间内存也有自己的地址，而线程这些都没有，线程只是依赖于进程
- 系统开销:多进程并发要比多线程程序健壮但是在进程切换时耗费资源较大，效率要差一些

联系:

- 一个线程只能属于一个进程，而一个进程可以有多个线程但至少有一个线程
- 资源分配给进程，同一进程的所有线程共享该进程的所有资源
- 真正在处理机上运行的是线程
- 线程在执行过程中需要进行同步而不同进程的线程间要利用消息通信的办法实现同步

协程**:是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理的而是完全是由程序所控制(即在用户态执行)**，这样对性能带来了很大的提升。一个协程就是执行一个子程序，协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候回来接着进行。

协程同多线程相比有什么优势?:

- 极高的执行效率，因为子程序切换不是线程切换而是由程序自身控制，所以没有线程切换的开销
- 不需要多线程的锁机制,因为只有一个线程也不存在同时写变量冲突，在协程中控制共享资源不加锁

## 进程间通信的方式 

 A: 无名管道（pipe）:半双工通信，单向流动，通常父子进程使用 

  高级管道（popen）:另一进程当做新进程在当前进程启动，把他当做当前进程的子进程。 

  有名管道（named pipe）:允许无亲缘关系的进程通信 

  消息队列（message queue）：消息[链表]()，解决了管道传递信息少，缓冲区大小受限问题 

  信号量（semphore）:一种计数器，常用于加锁，信号量常用的事pv操作，是一种不同进程间同步的手段 

  信号（sinal）:通知某进程，某事件已经发生 

  共享内存（shared memory）: 映射一些其他进程访问的内存，一般与信号量配合使用，实现进程同步与通信。 

  套接字（socket）:用与不同机器之间的进程通信

线程之间的通信：共享内存和管道

## 进程的状态转换

就绪状态->运行状态:**处于就绪状态的进程被调度后获得CPU资源**，于是进程就由就绪状态转换为运行状态

运行状态->就绪状态:**处于运行状态的进程在时间片用完后不得不让出CPU**，从而进程由运行状态转换为就绪状态

运行状态->阻塞状态:当进程请求某一资源的使用和分配或**等待某一事件发生时**，他就从运行状态转换为阻塞状态

阻塞状态->就绪状态:**当进程等待的事件到来时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态**

## PV操作(信号量及其应用)

信号量PV，P是阻塞原语负责把当前进程由运行状态转换成阻塞状态直到另一个进程唤醒，操作为把信号量-1，如果-1后sum仍大于等于0则P原语返回进程继续执行如果小于0则该进程被阻塞后进入该信号相对应得队列中

V是唤醒原语，负责把一个被阻塞得进程唤醒，操作为把信号量+1，如果发现有多个阻塞得进程就选择一个进行唤醒，如果+1后sum大于0则执行V得进程继续执行，如果相加结果小于等于0则从该信号得等待队列中唤醒一个等待进程然后再返回调度处继续执行

## 银行家算法

即一个银行家要为人办理贷款服务，需要办理的人需要在第一次就告知完成该项目所需最大的资金，银行家在判断该资金是否超过自己所持有的资金(确认是否是一次安全的借出)，如果没有超过那么就应该尽量借，然后要求他们及时归还

## 分页和分段

内存的分段和分页管理方式和由此衍生的一堆段页式都属于内存的不连续分配，即把程序分割成一块一块的装入内存，在物理上不用彼此相连，在逻辑上使用段或者页表将离散分布的这些小块穿起来形成逻辑上连续的 程序

在基本得分页概念中，我们把程序程序分为等长的小块，这些小块称为页，同样内存也被分成了和页面同样大小的页框，一个页可以装到一个页框里，在执行程序的时候我们根据一个页表去查找某个页面在内存的某个页框中，由此完成逻辑到物理的映射

分段和分页有很多类似的地方，但是最大的区别在于分页对于用户来说是没有什么逻辑意义的，分页只是为了完成离散存储，所有的页面大小都一样。但是分段不一样，分段不定长，分页由系统完成，分段有时在编译过程中会指定划分，因此可以保留部分逻辑特征，容易实现分段共享。

## CPU调优算法

先来先服务，短作业优先，优先级调度，多级反馈队列调度

## I/O

同步阻塞IO，用户线程在内核进行IO操作时被阻塞，即用户在对内核发起read请求时用户进入阻塞状态直到read完成

同步非阻塞IO:同步非阻塞IO是在同步阻塞IO的基础上将socket设置为NONBLOCK.这样做用户线程可以在发起IO请求后可以立即返回，即发起read请求后用户不会阻塞内核会立即返回

IO多路复用:IO多路复用模型时建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题

异步IO ：真正的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取处理，而在异步IO模型中当用户线程收到通知时，数据已经被内核读取完毕，并发放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用就可以了。

## 零拷贝

零拷贝是CPU不**执行拷贝**数据从一个存储区域到另一个存储区域的任务，这通常用于通过**网络传输一个文件时**以减少CPU周期和内存带宽

好处:

- 减少甚至完全避免不必要的CPU拷贝，从而让CPU解脱出来去执行其他任务
- 减少内存带宽的占用
- 通常零拷贝技术还能够减少用户空间和操作系统内核之间的上下文切换

## 原码、补码、反码

源码的最高位表示正负，正为0，负为1

正数的反码等于源码，负数的反码等于符号位不变其余按位取反

补码等于反码+1

## ————————————————————————————————



#### 简单请求

只要同时满足以下两大条件，就属于简单请求。：

（1) 请求方法是以下三种方法之一：

- HEAD
- GET
- POST

（2）HTTP的头信息不超出以下几种字段：

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

当浏览器发现发现的ajax请求是简单请求时，会在请求头中携带一个字段：`Origin`.

![img](https:////upload-images.jianshu.io/upload_images/5336514-75c42cd2868fc145.png?imageMogr2/auto-orient/strip|imageView2/2/w/481/format/webp)

Origin

Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。

如果服务器允许跨域，需要在返回的响应头中携带下面信息：



```http
Access-Control-Allow-Origin: http://manage.leyou.com
Access-Control-Allow-Credentials: true
Content-Type: text/html; charset=utf-8
```

- Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*，代表任意
- Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true

注意：

如果跨域请求要想操作cookie，需要满足3个条件：

- 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。
- 浏览器发起ajax需要指定withCredentials 为true
- 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名

#### 特殊请求

不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。

> 预检请求

特殊请求会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

一个“预检”请求的样板：



```http
OPTIONS /cors HTTP/1.1
Origin: http://manage.leyou.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.leyou.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

与简单请求相比，除了Origin以外，多了两个头：

- Access-Control-Request-Method：接下来会用到的请求方式，比如PUT
- Access-Control-Request-Headers：会额外用到的头信息

> 预检请求的响应

服务的收到预检请求，如果许可跨域，会发出响应：

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://manage.leyou.com
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Max-Age: 1728000
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

除了`Access-Control-Allow-Origin`和`Access-Control-Allow-Credentials`以外，这里又额外多出3个头：

- Access-Control-Allow-Methods：允许访问的方式
- Access-Control-Allow-Headers：允许携带的头
- Access-Control-Max-Age：本次许可的有效时长，单位是秒，**过期之前的ajax请求就无需再次进行预检了**

如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了



## 千分位转化

```javascript
     function numFormat(num) {
            num = num.toString().split(".");  // 分隔小数点
            var arr = num[0].split("").reverse();  // 转换成字符数组并且倒序排列
            var res = [];
            for (var i = 0, len = arr.length; i < len; i++) {
                if (i % 3 === 0 && i !== 0) {
                    res.push(",");   // 添加分隔符
                }
                res.push(arr[i]);
            }
            res.reverse(); // 再次倒序成为正确的顺序
            if (num[1]) {  // 如果有小数的话添加小数部分
                res = res.join("").concat("." + num[1]);
            } else {
                res = res.join("");
            }
            return res;
        }
```



## 柯理化

```javascript
       function add() {
            // 第一次执行时，定义一个数组专门用来存储所有的参数
            let _args = []
            _args.push(...arguments)
            // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
            let _adder = function () {
                _args.push(...arguments)
                return _adder
            };
            // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
            _adder.toString = function () {
                return _args.reduce(function (a, b) {
                    return a + b
                })
            }
            return _adder
        }
```



## promise.all

```javascript
      const all = iterable => {
            return new Promise((resolve, reject) => {
                let arr = []
                for (let i in iterable) {
                    let cur = iterable[i]
                    if (typeof cur === "object" && typeof cur.then === "function") {
                        cur.then((res) => {
                            arr[i] = res
                            if (arr.length === iterable.length) {
                                resolve(arr)
                            }
                        }, reject)
                    } else {
                        reject(cur)
                    }
                }
            })
        }
```



## 实现一个调度并发器，最多允许两个任务进行处理

```javascript
  //实现一个调度并发器，最多允许两个任务进行处理
        class Scheduler {
            constructor() {
                this.count = 2
                this.arr = []
            }
            addTask(time, str) {
                const fn = (resolve) => {
                    setTimeout(() => {
                        console.log(str)
                        resolve()
                    }, time * 1000)
                }
                this.arr.push(fn)
            }
            start() {
                let p = this.count
                for (let i = 0; i < p; i++) {
                    if (this.arr.length === 0) {
                        return
                    }
                    let fn = this.arr.shift()
                    new Promise(resolve => {
                        this.count--
                        fn(resolve)
                    }).then(() => {
                        this.count++
                        this.start()
                    })
                }
            }
        }



        const scheduler = new Scheduler();

        scheduler.addTask(2, "1"); //1s后输出1
        scheduler.addTask(2, "2"); //2s后输出2
        scheduler.addTask(2, "3"); //2s后输出4
        scheduler.addTask(2, "4"); //3s后输出3
        scheduler.start();
```





## 深拷贝 	

```javascript
// 深拷贝
function deepClone (obj) {
    const targetObj = obj.constructor === Array ? [] : {}
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (obj[key] && typeof obj[key] === "object") {
                targetObj[key] = obj[key].constructor === Array ? [] : {}
                targetObj[key] = deepClone(targetObj[key])
            } else {
                targetObj[key] = obj[key]
            }
        }
    }
    return targetObj
}
```



## new操作符实现

```javascript
function create(){
	//定义空对象
	let obj = new Object()
	//取出参数列表的第一个参数（构造函数）
	let Con = [].shift.call(arguments);
	//手动指正obj的构造函数为Con（链接原型）
	obj.__proto__ = Con.prototype;
	//调用Con，改变this为obj，传入剩余参数arguments
	let result = Con.apply(obj,arguments);
	//考虑到Con函数中有return的原因，需要对result进行判断
	return result instanceof Object ? result : obj
}
```



## 寄生组合式继承

```javascript
  function Parent(name) {
            this.name = name
            this.color = ['red', 'green']
        }
        Parent.prototype.getName = function () {
            console.log(this.name);
        }
        function Child(name, age) {
            Parent.call(this, name)
            this.age = age
        }
        if (!Object.create) {
            Object.create = function (proto) {
                function F() { }
                F.prototype = proto
                return new F()
            }
        }
        Child.prototype = Object.create(Parent.prototype)
        Child.prototype.constructor = Child
        let child = new Child('LW', 21)
        console.log(child);
        child.getName()

//封装成方法
  function inherit(partent, child) {
            let obj = Object.create(parent.prototype)
            obj.constructor = child
            child.prototype = obj
        }
```



## call，apply，bind实现

```javascript
// call模拟
Function.prototype.call_ = function (obj) {
    //判断是否为null或者undefined,同时考虑传递参数不是对象情况
    obj = obj ? Object(obj) : window;
    var args = [];
    // 注意i从1开始
    for (var i = 1, len = arguments.length; i < len; i++) {
        args.push("arguments[" + i + "]");
    };
    obj.fn = this; // 此时this就是函数fn
    var result = eval("obj.fn(" + args + ")"); // 执行fn
    delete obj.fn; //删除fn
    return result;
};
// apply模拟
Function.prototype.apply_ = function (obj, arr) {
    obj = obj ? Object(obj) : window;
    obj.fn = this;
    var result;
    if (!arr) {
        result = obj.fn();
    } else {
        var args = [];
        // 注意这里的i从0开始
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push("arr[" + i + "]");
        };
        result = eval("obj.fn(" + args + ")"); // 执行fn
    };
    delete obj.fn; //删除fn
    return result;
};
// ES6 call
Function.prototype.call_ = function (obj) {
    obj = obj ? Object(obj) : window;
    obj.fn = this;
    // 利用拓展运算符直接将arguments转为数组
    let args = [...arguments].slice(1);
    let result = obj.fn(...args);

    delete obj.fn
    return result;
};
// ES6 apply
Function.prototype.apply_ = function (obj, arr) {
    obj = obj ? Object(obj) : window;
    obj.fn = this;
    let result;
    if (!arr) {
        result = obj.fn();
    } else {
        result = obj.fn(...arr);
    };

    delete obj.fn
    return result;
};
//bind
Function.prototype.bind_ = function (obj) {
    if (typeof this !== "function") {
        throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    };
    var args = Array.prototype.slice.call(arguments, 1);
    var fn = this;
    //创建中介函数
    var fn_ = function () {};
    var bound = function () {
        var params = Array.prototype.slice.call(arguments);
        //通过constructor判断调用方式，为true this指向实例，否则为obj
        fn.apply(this.constructor === fn ? this : obj, args.concat(params));
        console.log(this);
    };
    fn_.prototype = fn.prototype;
    bound.prototype = new fn_();
    return bound;
};
```



## 数组扁平化

```java
//不改变原数组
function flatten (arr) {
    return arr.reduce((pre, v) => {
        return pre.concat(Array.isArray(v) ? flatten(v) : v)
    }, [])
}
改变原数组
const flattens = (arr) => {
    for (let i = 0; i < arr.length; i++) {
        if (Array.isArray(arr[i])) {
            flattens(arr[i])
            let len = arr[i].length
            arr.splice(i, 1, ...arr[i])
            i += len - 1
        }
    }
}
```



## 判断数组的方法

### **① instanceof 操作符判断**

**用法：arr instanceof Array**
**instanceof 主要是用来判断某个实例是否属于某个对象**

```
function obj(){}
let o1 = new obj();
console.log(o1 instanceof obj);  // true
```

那么我们用instanceof 来判断数组的方法如下：

```
let arr = [];
console.log(arr instanceof Array); // true
```

> 但是 instanceof 会有一个问题，**它的问题在于假定只有一个全局执行的环境**。如果网页中包含多个框架，那实际上就存在**两个以上不同的全局执行环境**，**从而存在两个以上不同版本的Array构造函数**。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有不同的构造函数。

### **②对象构造函数的 constructor判断**

**用法：arr.constructor === Array**
**Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数**

```
function obj(){}
let o1 = new obj();
console.log(o1.constructor === obj);  // true
```

如上所示，obj 的实例 o1 的 constructor 跟 obj 对象是相等的
那么我们就可以用此来判断数组了

```
let arr = [];
console.log(arr.constructor === Array); // true
```

### **③Array 原型链上的 isPrototypeOf**

**用法：Array.prototype.isPrototypeOf(arr**)
**Array.prototype  属性表示 Array 构造函数的原型**
其中有一个方法是 isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。

```
let arr = [];
console.log(Array.prototype.isPrototypeOf(arr)); // true
```

### **④Object.getPrototypeOf**

**用法：Object.getPrototypeOf(arr) === Array.prototype**
**Object.getPrototypeOf() 方法返回指定对象的原型**

所以只要跟Array的原型比较即可

```
let arr = [];
console.log(Object.getPrototypeOf(arr) === Array.prototype); // true
```

### **⑤Object.prototype.toString**

**用法：Object.prototype.toString.call(arr) === '[object Array]'**

虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。

```
let arr = [];
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true
```

### **⑥Array.isArray**

**用法：Array.isArray(arr)**
**ES5中新增了Array.isArray方法,IE8及以下不支持**

Array.isArray ( arg )
isArray 函数需要一个参数 arg，如果参数是个对象并且 class 内部属性是 "Array", 返回布尔值 true；否则它返回 false。采用如下步骤：
      如果 Type(arg) 不是 Object, 返回 false。
      如果 arg 的 [[Class]] 内部属性值是 "Array", 则返回 true。
      返回 false.

```
let arr = [];
console.log(Array.isArray(arr)); // true
```

## instanceof原理

```javascript
function instance_of(L, R) {//L 表示左表达式，R 表示右表达式 

    var O = R.prototype;   // 取 R 的显示原型 

    L = L.__proto__;  // 取 L 的隐式原型

    while (true) {    

        if (L === null)      

             return false;   

        if (O === L)  // 当 O 显式原型 严格等于  L隐式原型 时，返回true

             return true;   

        L = L.__proto__;  

    }

}
```

### 案例：未发生继承关系时

```javascript
 function Person(name,age,sex){
 
     this.name = name;
 
     this.age = age;
 
     this.sex = sex;
 
 }
 
 function Student(score){
 
     this.score = score;
 
  }
 
 var per = new Person("小明"，20，“男”)；
 
 var stu = new Student（98）；
 
 console.log(per instanceof Person);  // true
 
 console.log(stu instanceof Student);  // true
 
 console.log(per instanceof Object);  // true
 
 console.log(stu instanceof Object);  // true
```

#### 1、下图1是未发生继承关系时的原型图解：

![img](https:////upload-images.jianshu.io/upload_images/13525005-a23c9129e5564e93.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/675/format/webp)

图1  未发生继承关系时的原型图解

#### 2、instanceof的工作流程分析

**首先看per instanceof Person**



```jsx
 function instance_of(L, R) { // L即per ；  R即Person
 
   var O = R.prototype; //O为Person.prototype
 
   L = L.__proto__;       // L为per._proto_
 
   while (true) {    //执行循环
 
        if (L === null)   //不通过
 
            return false;   
 
        if (O === L)       //判断：Person.prototype ===per._proto_？
 
             return true;  //如果等于就返回true，证明per是Person类型
 
        L = L.__proto__;                   
 
   }
 
}         
```

执行per instanceof Person  ，通过图示看出 Person.prototype ===per.*proto* 是成立的，所以返回true，证明引用per是属于构造函数Person的。

**接下来再看   per instanceof Object**



```jsx
 function instance_of(L, R) { //L即per ；  R即Object        

    var O = R.prototype;  //O为Object.prototype        
 
    L = L.__proto__;    // L为per._proto_             
 
    while (true) {     //执行循环                   
 
        if (L === null)   //不通过                            
 
            return false;                      
 
        if (O === L)   //Object .prototype === per._proto_？  不成立**
 
             return true;                         
 
         L = L.__proto__;   //令L为 per._proto_ ._proto_ ，**
 
                         //即图中Person.prototype._proto_指向的对象
 
                         //接着执行循环，
 
                         //到Object .prototype === per._proto_ ._proto_  ？
 
                         //成立，返回true
 
          }
 
 }
```

### 案例：发生继承关系时

```jsx
 function Person(name,age,sex){
 
     this.name = name;
 
     this.age = age;
 
     this.sex = sex;
 
 }
 
 function Student(name,age,sex,score){
 
     Person.call(this,name,age,sex);  
 
     this.score = score;
 
  }
 
 Student.prototype = new Person();  // 这里改变了原型指向，实现继承
 
 var stu = new Student("小明",20,"男",99); //创建了学生对象stu
 
 console.log(stu instanceof Student);    // true
 
 console.log(stu instanceof Person);    // true
 
 console.log(stu instanceof Object);    // true
```

#### 1、下图2是发生继承关系后的原型图解

![img](https:////upload-images.jianshu.io/upload_images/13525005-1f4110c78c84c0aa.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/668/format/webp)

图2  发生继承关系后的原型图解

#### 2、instanceof的工作流程分析

**首先看 stu instanceof Student**



```jsx
 function instance_of(L, R) { //L即stu ；  R即Student
 
   var O = R.prototype;  //O为Student.prototype,现在指向了per
 
    L = L.__proto__;    //L为stu._proto_，也随着prototype的改变而指向了per
 
    while (true) {    //执行循环
 
          if (L === null)  //不通过
 
              return false;   
 
          if (O === L)    //判断： Student.prototype ===stu._proto_？
 
              return true;  //此时，两方都指Person的实例对象per，所以true
 
          L = L.__proto__;                   
 
      }
 
 } 
```

所以，即使发生了原型继承，stu instanceof Student 依然是成立的。

**接下来看 stu instanceof Person，instanceof是如何判断stu继承了Person**



```jsx
 function instance_of(L, R) { // L即stu ；  R即Person        
 
   var O = R.prototype; // O为Person.prototype     
 
    L = L.__proto__;   //L为stu._proto_，现在指向的是per实例对象
 
    while (true) {   // 执行循环                   
 
       if (L === null)   //不通过                            
 
           return false;                    
 
       if (O === L)    //判断：   Person.prototype === stu._proto_ ？      
 
            return true;   //此时，stu._proto_ 指向per实例对象，并不满足
 
        L = L.__proto__;  //令L=  stu._proto_._proto_，执行循环
 
   }                      //stu._proto_ ._proto_，看图示知：
 
}                        //指的就是Person.prototype，所以也返回true
```



## 宏任务微任务event  loop

![image-20210803203259976](面试.assets/image-20210803203259976.png)

## 浮点数精度

ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。

在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数

[![IEEE754](https://camo.githubusercontent.com/8a1cc45ff11a176af57f5cec9998addda44ebc193b2d19e7d103a37b6036686d/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067)](https://camo.githubusercontent.com/8a1cc45ff11a176af57f5cec9998addda44ebc193b2d19e7d103a37b6036686d/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067)

在这个标准下：

- 符号位：1 位用于标志位。0正1负
- 指数位：11 位用于指数。分一半给负数, 最大到 1024
- 尾数位：剩下的 52 位代表的是尾数，超出的部分自动进一舍零

关于浮点数的运算，一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。

JS能表示的最大整数是2的53次方-1，`这个数是16位` Number.MAX_SAFE_INTEGER

0.1的**浮点数二进制码是有误差的**,在进行浮点数运算时，比如0.1+0.2 != 0.3，解决思路如下：
1.将结果四舍五入
2.将浮点数转化为整数再将结果除以扩大倍数
3.把浮点数转化为字符串，模拟实际运算的过程

## BFC

**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。**

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

### BFC作用

1. 解决上下元素的外边距重叠，属于同一个BFC的元素会发生外边距重叠，给其中一个元素包裹一层触发BFC
2. 解决父子元素的margin重叠问题，给父元素触发bfc
3. BFC不会重叠浮动元素， 不想文字包裹浮动元素，可以给文字元素触发BFC
4. 清除浮动，让父元素触发BFC，解决父元素高度塌陷的问题

### 触发 BFC

只要元素满足下面任一条件即可触发 BFC 特性：

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)

### 清楚浮动的方式

1. 在浮动元素的后面加一个div，设置clear：both
2. 在父元素中添加伪元素，`::after: content: ''; display: block; clear:both `
3.  触发BFC
4. 知道父元素的高度，为父元素添加高度

## 白屏-性能优化

至此，我们已经了解了从浏览器在打开一个链接开始，到屏幕展示的过程-白屏时间的历程，那这对每个环节中发生的事情，我们可以有针对性的进行相关的优化。

### 1. DNS解析优化

针对DNS Lookup环节，我们可以针对性的进行DNS解析优化。

- DNS缓存优化
- DNS预加载策略
- 稳定可靠的DNS服务器

### 2. TCP网络链路优化

针对网络链路的优化，好像除了花钱没有什么更好的方式！

### 3. 服务端处理优化

服务端的处理优化，是一个非常庞大的话题，会涉及到如[Redis](https://cloud.tencent.com/product/crs?from=10680)缓存、数据库存储优化或是系统内的各种中间件以及Gzip压缩等...

### 4. 浏览器下载、解析、渲染页面优化

根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理：

- 尽可能的精简HTML的代码和结构
- 尽可能的优化CSS文件和结构
- 一定要合理的放置JS代码，尽量不要使用内联的JS代码

### 5.图片懒加载

### 6.路由懒加载

## 页面生成的过程：

1.HTML 被 HTML 解析器解析成 DOM 树；

2.CSS  被 CSS 解析器解析成 CSSOM 树；

3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；

4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；

5.将布局绘制(paint)在屏幕上，显示出整个页面。

第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。



![image](https://user-gold-cdn.xitu.io/2020/3/6/170af501e710ce67?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



## 重排与重绘

### 重排优化：

重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。

### 减少重排范围

我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。

- 尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。
- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。

### 减少重排次数

#### 1.样式集中改变

不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 `cssText` 变量中编辑。虽然现在大部分现代浏览器都会有 `Flush` 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。

```
// bad
var left = 10;
var top = 10;
el.style.left = left + "px";
el.style.top = top + "px";

// 当top和left的值是动态计算而成时...
// better 
el.style.cssText += "; left: " + left + "px; top: " + top + "px;";

// better
el.className += " className";

复制代码
```

#### 2.分离读写操作

DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。

```
// bad 强制刷新 触发四次重排+重绘
div.style.left = div.offsetLeft + 1 + 'px';
div.style.top = div.offsetTop + 1 + 'px';
div.style.right = div.offsetRight + 1 + 'px';
div.style.bottom = div.offsetBottom + 1 + 'px';


// good 缓存布局信息 相当于读写分离 触发一次重排+重绘
var curLeft = div.offsetLeft;
var curTop = div.offsetTop;
var curRight = div.offsetRight;
var curBottom = div.offsetBottom;

div.style.left = curLeft + 1 + 'px';
div.style.top = curTop + 1 + 'px';
div.style.right = curRight + 1 + 'px';
div.style.bottom = curBottom + 1 + 'px';
复制代码
```

原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：

> 当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。

#### 3.将 DOM 离线

“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：

- 使用 display:none

  一旦我们给元素设置 `display:none` 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 `display`属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，`visibility : hidden` 的元素只对重绘有影响，不影响重排。

- 通过 [documentFragment](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment) 创建一个 `dom` 碎片,在它上面批量操作 `dom`，操作完成之后，再添加到文档中，这样只会触发一次重排。

- 复制节点，在副本上工作，然后替换它！

#### 4.使用 absolute 或 fixed 脱离文档流

使用绝对定位会使的该元素单独成为渲染树中 `body` 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。

#### 5.优化动画

- 可以把动画效果应用到 `position`属性为 `absolute` 或 `fixed` 的元素上，这样对其他元素影响较小。

  动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多

- 启用GPU加速 `GPU` 硬件加速是指应用 `GPU` 的图形性能对浏览器中的一些图形操作交给 `GPU` 来完成，因为 `GPU` 是专门为处理图形而设计，所以它在速度和能耗上更有效率。

  `GPU` 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。

  ```
    /*
    * 根据上面的结论
    * 将 2d transform 换成 3d
    * 就可以强制开启 GPU 加速
    * 提高动画性能
    */
    div {
      transform: translate3d(10px, 10px, 0);
  ```



渲染的三个阶段 Layout，Paint，Composite Layers。 Layout：重排，又叫回流。 Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。

CSS3 就是在 GPU 发生的：Transform  Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。

## 内存泄漏

全局变量不会被垃圾回收（也可能是正常的内存开销）

分离的dom节点

闭包

控制台打印等

## vue生命周期

![img](https://upload-images.jianshu.io/upload_images/13119812-5890a846b6efa045.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)



### compute

适用于一些重复使用数据或复杂及费时的运算。我们可以把它放入computed中进行计算, 然后会在computed中缓存起来, 下次就可以直接获取了。

如果我们需要的数据依赖于其他的数据的话, 我们可以把该数据设计为computed中。

computed 是基于响应性依赖来进行缓存的。只有在响应式依赖发生改变时它们才会重新求值, 也就是说, 当msg属性值没有发生改变时, 多次访问 reversedMsg 计算属性会立即返回之前缓存的计算结果, 而不会再次执行computed中的函数。但是methods方法中是每次调用, 都会执行函数的, methods它不是响应式的。

computed中的成员可以只定义一个函数作为只读属性, 也可以定义成 get/set变成可读写属性, 但是methods中的成员没有这样的。

### watch

watch它是一个对data的数据监听回调, 当依赖的data的数据变化时, 会执行回调。在回调中会传入newVal和oldVal两个参数。

**理解handler方法及immediate属性**

watch当中的方法默认就是这个handler方法。但是在这里我们使用了immediate: true; 属性，含义是: 如果在watch里面声明了age的话, 就会立即执行里面的handler方法。如果 immediate 值为false的话,那么效果就和之前的一样, 就不会立即执行handler这个方法的。因此设置了 immediate:true的话,第一次页面加载的时候也会执行该handler函数的

**理解deep属性**

watch里面有一个属性为deep，含义是：是否深度监听某个对象的值, 该值默认为false。

**watch 和 computed的区别是：**

相同点：他们两者都是观察页面数据变化的。

不同点：computed只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。
watch每次都需要执行函数。watch更适用于数据变化时的异步操作。

## vue父子组件通信方式

1.props与$emit

2 回调函数(callback)

3 $parent + $children

4 provide + inject   (父子组件直接定义获取)

5 $attrs + $ilsteners

6  ref  $refs

7 插槽slot

8 event bus

## CSS权重

CSS选择器包括行内样式、`id`选择器、`class`选择器、标签选择器，优先级依次降低，`!important`可用于优先级提升，比行内样式优先级还要高，权重的计算依次为`1000`,`100`,`10`,`1`，`!important`的优先级为正无穷。

`1000,100,10,1`不是十进制中的`1000,100,10,1`，而是进制数，不是`2`进制，不是`10`进制，而是`256`进制，就是`0`到`255`后`+1`才是`1`，比如通配符的权重为`0`，伪元素的权重为`1`，中间相差了`255`，依次类推。

### 权重计算规则

第一优先级：`!important`会覆盖页面内任何位置的元素样式

1.内联样式，如`style="color: green"`，权值为`1000`

2.ID选择器，如`#app`，权值为`0100`

3.类、伪类、属性选择器，如`.foo, :first-child, div[class="foo"]`，权值为`0010`

4.标签、伪元素选择器，如`div::first-line`，权值为`0001`

5.通配符、子类选择器、兄弟选择器，如`*, >, +`，权值为`0000`

6.继承的样式没有权值

## var、let、const区别

1. const 声明之后必须马上赋值，否则会报错
2. const 简单类型一旦声明就不能再更改，
3. let 、const块级作用域

4. let 、const不存在变量提升
5. let 、const存在暂时性死区
6. let 、const不可重复声明
7. var声明的全局变量会挂在顶层对象下面,存在变量提升

## 垃圾回收算法

![image-20210802192632907](面试.assets/image-20210802192632907.png)

变量都会存在新生代中，新生代两个部分，from和to，垃圾清除算法，新生代互换

![image-20210802192859708](面试.assets/image-20210802192859708.png)

有一半的空间被浪费

老生代算法

早期是：标记清除，从根节点出发

![image-20210802193505794](面试.assets/image-20210802193505794.png)

标记整理的时候是先整理再清除。在整理的时候可以通过覆盖的方式清楚一些变量

运行主线程->垃圾回收->主线程->垃圾回收，一层一层，通过三色标记法

![image-20210802194058635](面试.assets/image-20210802194058635.png)



## 说一说VUE3.0响应式的理解

Vue3.0改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。而且作为新标准将受到浏览器厂商重点持续的性能优化。

## Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？

​    判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。

## 监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？

​    我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。

## Proxy 与 Object.defineProperty 优劣对比

Proxy 的优势如下:

​    1）Proxy 可以直接监听对象而非属性；

​    2）Proxy 可以直接监听数组的变化；

​    3）Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；

​    4）Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；

​    5）Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

​    Object.defineProperty 的优势如下:

​    兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。

## 对 SPA 单⻚⾯的理解，优缺点是什么？

​    SPA（ single-page application ）仅在 Web ⻚⾯初始化时加载相应的 HTML、JavaScript 和 CSS。⼀旦⻚⾯加载完成，SPA 不会因为⽤户的操作⽽进⾏⻚⾯的重新加载或跳转；取⽽代之的是利⽤路由机制实现 HTML 内容的变换，UI 与⽤户的交互，避免⻚⾯的重新加载。

​    优点：

​    1）⽤户体验好、快，内容的改变不需要重新加载整个⻚⾯，避免了不必要的跳转和重复渲染；

​    2）SPA 相对对服务器压⼒⼩；

​    3）前后端职责分离，架构清晰，前端进⾏交互逻辑，后端负责数据处理；

​    缺点：

​    1）⾸屏（初次）加载慢：为实现单⻚ Web 应⽤功能及显示效果，需要在加载⻚⾯的时候将JavaScript、CSS 统⼀加载，部分⻚⾯按需加载；

​    2）不利于 SEO：由于所有的内容都在⼀个⻚⾯中动态替换显示，所以在 SEO 上其有着天然的弱势。

​    

##  Vue.js 的优点是什么

​    Vue.js性能好，非常容易优化。

​    Vue.js体积小，包含了 Vuex + Vue Router 的 Vue 项目 (gzip 之后 30kB) 。

​    Vue.js更加灵活，Vue 官方提供了构建工具来协助你构建项目，但它并不限制你去如何组织你的应用代码。

​    Vue.js容易上手。要学习 Vue，你只需要有良好的 HTML 和 JavaScript 基础，API也比较少。

​    Vue.js生态系统丰富，很多开源组件和UI框架。

## Vue中key的作用

`key`的特殊`attribute`主要用在`Vue`的虚拟`DOM`算法，在新旧`Nodes`对比时辨识`VNodes`。如果不使用`key`，`Vue`会使用一种最大限度减少动态元素并且尽可能的尝试就地修改、复用相同类型元素的算法，

使用`key`时，它会基于`key`的变化重新排列元素顺序，并且会移除`key`不存在的元素。此外有相同父元素的子元素必须有独特的`key`，重复的`key`会造成渲染错误。

## Vue.use是干什么的？原理是什么？

​    vue.use 是用来使用插件的，我们可以在插件中扩展全局组件、指令、原型方法等。

​    1､检查插件是否注册，若已注册，则直接跳出；

​    2､处理入参，将第一个参数之后的参数归集，并在首部塞入 this 上下文；

​    3､执行注册方法，调用定义好的 install 方法，传入处理的参数，若没有 install 方法并且插件本身为 function 则直接进行注册；

## axios取消请求

![image-20210806122322679](面试.assets/image-20210806122322679.png)

![image-20210806134406416](面试.assets/image-20210806134406416.png)

### axios 的 cancelToken

![image-20210806134441257](面试.assets/image-20210806134441257.png)



![image-20210806134536480](面试.assets/image-20210806134536480.png)



`axios`是一个主流的`http`请求库，它提供了两种取消请求的方式。

- 通过`axios.CancelToken.source`生成取消令牌`token`和取消方法`cancel`

- ```javascript
  onst CancelToken = axios.CancelToken;
  const source = CancelToken.source();
  
  axios.get('/user/12345', {
    cancelToken: source.token
  }).catch(function(thrown) {
    if (axios.isCancel(thrown)) {
      console.log('Request canceled', thrown.message);
    } else {
      // handle error
    }
  });
  
  axios.post('/user/12345', {
    name: 'new name'
  }, {
    cancelToken: source.token
  })
  
  // cancel the request (the message parameter is optional)
  source.cancel('Operation canceled by the user.');
  ```

- 通过`axios.CancelToken`构造函数生成取消函数

  ```javascript
  const CancelToken = axios.CancelToken;
  let cancel;
  
  axios.get('/user/12345', {
    cancelToken: new CancelToken(function executor(c) {
      // An executor function receives a cancel function as a parameter
      cancel = c;
    })
  });
  
  // cancel the request
  cancel();
  ```

> 需要注意的是在`catch`中捕获异常时，应该使用`axios.isCancel()`判断当前请求是否是主动取消的，以此来区分普通的异常逻辑。

### 在 axios 拦截器中使用

主要的方法已经写好了，只需要添加到`axios`拦截器中就可以了。

```javascript
axios.interceptors.request.use(config => {
  removePending(options) // 在请求开始前，对之前的请求做检查取消操作
  addPending(options) // 将当前请求添加到 pending 中
  // other code before request
  return config
}, error => {
  return Promise.reject(error)
})

axios.interceptors.response.use(response => {
  removePending(response) // 在请求结束后，移除本次请求
  return response
}, error => {
  if (axios.isCancel(error)) {
    console.log('repeated request: ' + error.message)
  } else {
    // handle error code
  }
  return Promise.reject(error)
})
```

将`clearPending()`方法添加到`vue`路由钩子函数中

```javascript
router.beforeEach((to, from, next) => {
  clearPending()
  // ...
  next()
})
```

## 箭头函数和普通函数的区别

箭头函数没有super和new.target的绑定

![image-20210805163232174](面试.assets/image-20210805163232174.png)

## 模拟new

![image-20210805172856592](面试.assets/image-20210805172856592.png)

### WebSocket 是基于TCP/IP协议，独立于HTTP协议的通信协议

https://zhuanlan.zhihu.com/p/145628937

## 盒子模型

![image-20210805204938613](面试.assets/image-20210805204938613.png)

## JWT

![image-20210805211450653](面试.assets/image-20210805211450653.png)

![image-20210805211607763](面试.assets/image-20210805211607763.png)

![image-20210805211738451](面试.assets/image-20210805211738451.png)

## base64加密

![image-20210805212508554](面试.assets/image-20210805212508554.png)

## 原型链

![image-20210805221430888](面试.assets/image-20210805221430888.png)



## Diff

![image-20210806132754945](面试.assets/image-20210806132754945.png)

## diff算法的o(n)^3

### 传统diff算法

传统的diff算法计算一棵树变成另一棵所需要的最少步骤的复杂度是O(n^3)，如何得到？

- 旧树上的一个节点，它要跟新树上的所有节点对比(复杂度为O(n))
- 如果这个节点在新树上没有找到，那么这个节点将被删除，同时会从新树中遍历找几个节点去填补(复杂度增加到O(n^2))
- 旧树上的所有节点都会走这个过程(复杂度增加到O(n^3))

### React diff

react diff 制定的三个策略

- Web UI中的DOM节点跨层级的移动特别少，可以忽略不计（tree diff）；
- 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构（component diff）；
- 对于同一层级的一组子节点，他们可以通过唯一的key进行区分（element diff）；

#### tree diff

基于策略一，react对树的算法进行分层比较优化，两颗树只会对处在同一层级的节点进行比较。

按照策略一忽略了跨层级之间的移动操作，react tree diff只会对相同颜色内的DOM节点进行比对，当发现某一层级的节点已经不存在了，则该节点及其所有子节点都会被完全删除掉，不会进行进一步的比对，这样只需要对树遍历一次便能完成整个DOM树的比较，复杂度变为了O(n)

#### Vue和React的diff[算法]()有什么区别：

1. Vue 2.X进行diff时，调用patch打补丁函数，一边比较一边给真实的DOM打补丁

2. Vue2.X对比节点，当节点元素类型相同，但是className不同时，认为是不同类型的元素，删除重新创建，而react则认为是同类型节点，进行修改操作

3. ① Vue 2.X的列表比对，采用从两端到中间的方式，旧集合和新集合两端各存在两个指针，两两进行比较，如果匹配上了就按照新集合去调整旧集合，每次对比结束后，指针向队列中间移动；
   ② 而react则是从左往右依次对比，利用元素的index和标识lastIndex进行比较，如果满足index < lastIndex就移动元素，删除和添加则各自按照规则调整；
   ③ 当一个集合把最后一个节点移动到最前面，react会把前面的节点依次向后移动，而Vue只会把最后一个节点放在最前面，这样的操作来看，Vue的diff性能是高于react的

4. Vue3.x借鉴了 ivi[算法]()和 inferno[算法]()。在创建VNode时就确定其类型，以及在mount/patch的过程中采用**位运算**来判断一个VNode的类型，在这个基础之上再配合核心的Diff[算法]()，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x[源码]()看)

   > 该[算法]()中还运用了[动态规划]()的思想求解最长递归子序列

## 事件循环

![image-20210806133505436](面试.assets/image-20210806133505436.png)

![image-20210806133827561](面试.assets/image-20210806133827561.png)

![image-20210806134011461](面试.assets/image-20210806134011461.png)

为让这个回调函数延迟执行，vue 优先用`promise`来实现，其次是 html5 的 `MutationObserver`，然后是`setTimeout`。前两者属于`microtask`，后一个属于 `macrotask`。

## CSS基础：块元素、内联元素、内联块元素

#### 常用的块状元素有：

```xml
<div>、<p>、<h1>-<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote> 、<form>
```

#### 常用的内联元素有：

```xml
<a>、<span>、<br>、<i>、<em>、<strong>、<label>、<q>、<var>、<cite>、<code>
```

#### 常用的内联块状元素有：

```xml
<img>、<input>
```

### 块级元素

设置display:block就是将元素显示为块级元素。如下代码就是将**内联元素a**转换为**块状元素**，从而使a元素具有**块状元素**特点。

```css
a{display:block;}
```

**块级元素特点：**

> 1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）
>  2、元素的高度、宽度、行高以及顶和底边距都可设置。
>  3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。

### 内联元素

在html中，

```xml
<span>、<a>、<label>、 <strong> 和<em>
```

就是典型的**内联元素**（**行内元素**）（inline）元素。当然**块状元素**也可以通过代码

```cpp
display:inline
```

将元素设置为**内联元素**。如下代码就是将**块状元素div**转换为**内联元素**，从而使 div 元素具有**内联元素**特点。

```css
div{
 display:inline;
 }
```

**内联元素特点：**

> 1、和其他元素都在一行上；
>  2、元素的高度、宽度及顶部和底部边距**不可**设置；
>  3、元素的宽度就是它包含的文字或图片的宽度，不可改变。

### 内联块状元素

**内联块状元素（**inline-block**）**就是同时具备内联元素、块状元素的特点，代码

```cpp
display:inline-block
```

就是将元素设置为内联块状元素。(css2.1新增)，

```xml
<img>、<input>
```

标签就是这种内联块状标签。

**inline-block 元素特点：**

> 1、和其他元素都在一行上；
>  2、元素的高度、宽度、行高以及顶和底边距都可设置。



## Es module 和commonJS的区别

- **区别一**

  > ES module 属于编译时加载，在编译的时候就能确定模块之间的关系；而CommonJS属于运行时加载，采用ES module的好处是可以做到tree sharking。
  >
  > ES module无法做到运行时加载，因此提出了import( )函数，完成运行时加载，和require( )的区别是，import( )是异步执行的，而require( )是同步执行的。

- **区别二**

  > ES module可以加载到模块的部分内容，而CommonJS需要加载整个文件，然后在拿到其中的内容。

- **区别三**

  > ES module输出的是值得引用，而CommonJS输出的是值的拷贝。

## CDM 和 [AMD]()

> 在这里顺便提一下[AMD]() 和 CMD的区别吧

1. **在定义模块时，对依赖的处理不同**：[AMD]()推崇依赖前置，在定义模块的时候要声明其依赖的模块；而CMD推崇就近依赖，只有在用到某个模块时才会进行require( )
2. **对依赖模块执行时机的处理不同**：[AMD]()在依赖模块加载完成后直接执行依赖模块，依赖的执行顺序和属性顺序不一定一致。CMD在依赖模块加载完成后并不执行，只是下载。等到所有的依赖模块都加载好之后，进入回调的函数逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。

## webpack是怎么运行起来的

Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

- `初始化参数`：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
- `开始编译`：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
- `确定入口`：根据配置中的 entry 找出所有的入口文件
- `编译模块`：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
- `完成模块编译`：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
- `输出资源`：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
- `输出完成`：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

在以上过程中，`Webpack` 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

## Webpack loader和plugin的区别

- Loader` 本质就是一个函数，在该函数中对接收到的内容进行转换。 因为 Webpack 只认识 [JavaScript]()，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。
- `Plugin` 就是插件，基于事件流框架 `Tapable`，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。
- `Loader` 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。
- `Plugin` 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。

1. webpack loader是用来加载文件的，webpack plugin是用来扩展功能的。
2. loader主要是用来加载一个个文件的，比如它可以加载js文件并把js文件转译成低版本浏览器可以支持的js文件；也可以用来加载css文件，可以把css文件变成页面上的style标签；还可以加载图片文件，可以对文件进行优化。
3. plugin是用来加强webpack功能的，比如**HTML webpack plugin**是用来生成一个html文件的；再比如**mini css extract plugin**是用来抽取css代码并把它变成一个css文件的。

## 数组和链表的区别

数组：查询效率高，新增和修改需要移动元素效率低，内存分配是连续的内存，扩容需要重新分配内存。

链表：新增和修改效率高，只需要修改指针指向就好。链表查询效率低，需要从链表头依次查找。内存分配不需要连续的内存，占用连续内存少。

## ES5实现const

- configurable：当前对象元素的属性描述符是否可改，是否可删除
- enumerable：当前对象元素是否可枚举

```js
 window.data = value // 把要定义的data挂载到window下，并赋值value
        Object.defineProperty(window, data, { // 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符
          enumerable: false,
          configurable: false,
          get: function () {
            return value
          },
          set: function (data) {
            if (data !== value) { // 当要对当前属性进行赋值时，则抛出错误！
              throw new TypeError('Assignment to constant variable.')
            } else {
              return value
            }
          }
        })
```

## flex

```
flex-flow: <flex-direction><flex-wrap>

flex:  <flex-grow> <flex-shrink> <flex-basis> 
1.flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
2.flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
3.flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。
```

**flex: 1; === flex: 1 1 0%;**

flex:auto;`===`flex: 1 1 auto

还有两种写法，分别是 **initial (0 1 auto)** 和 **none (0 0 auto)**

- 第一个参数表示: **flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大**
- 第二个参数表示: **flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小**
- 第三个参数表示: **flex-basis **给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小

auto 为表示项目本身的大小, **如果设置为 auto, 那么这三个盒子就会按照自己内容的多少来等比例的放大和缩小**, 所以出现了上图中三个盒子不一样大的情况

那我们如果**随便设置一个其他带有长度单位的数字**呢, 那么他就不会按项目本身来计算, 所以它不关心内容, 只是把空间等比收缩和放大

# 响应式原理的不同

![image-20210813143311289](面试.assets/image-20210813143311289.png)

Vue2.x实现双向数据绑定原理，是通过es5的 Object.defineProperty，根据具体的key去读取和修改。其中的setter方法来实现数据劫持的，setter实现数据的修改。但是必须先知道想要拦截和修改的key是什么，所以vue2对于新增的属性无能为力，比如无法监听属性的添加和删除、数组索引和长度的变更，vue2的解决方法是使用Vue.set(object, propertyName, value) 等方法向嵌套对象添加响应式。

Vue3.x使用了ES2015的更快的原生proxy 替代 Object.defineProperty。Proxy可以理解成，在对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy可以直接监听对象而非属性，并返回一个新对象，具有更好的响应式支持

# 生命周期的不同

beforeCreate -> 请使用 setup()

created -> 请使用 setup()

beforeMount -> onBeforeMount

mounted -> onMounted

beforeUpdate -> onBeforeUpdate

updated -> onUpdated

beforeDestroy -> onBeforeUnmount

destroyed -> onUnmounted

errorCaptured -> onErrorCaptured

如果要想在页面中使用生命周期函数，以往vue2的操作是直接在页面中写入生命周期，而vue3是需要去引用的，这就是为什么3能够将代码压缩到更低的原因

# 判断数据类型

### 1.使用typeof

### 2.使用instanceof

### 3.使用constructor

>  undefined和null没有contructor属性

### 4.使用Object.prototype.toString.call

# parseInt默认值

如果 `radix` 是 `undefined`、`0`或未指定的，JavaScript会假定以下情况：

1. 如果输入的 `string`以 "`0x`"或 "`0x`"（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被当做十六进制数去解析。
2. 如果输入的 `string`以 "`0`"（0）开头， `radix`被假定为`8`（八进制）或`10`（十进制）。具体选择哪一个radix取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。**因此，在使用 `parseInt` 时，一定要指定一个 radix**。
3. 如果输入的 `string` 以任何其他值开头， `radix` 是 `10` (十进制)。

如果第一个字符不能转换为数字，`parseInt`会返回 `NaN`。

# Axios、ajax、fetch

关于Ajax XMLHttpRequest、axios、fetch

ajax -> 对原生XML的封装，还支持JSONP （）

fetch 号称是ajax的替代品 -> api 基于Promise ->链式调用的方式 -> **fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象**。

axios的话 本质上也是对原生XHR的封装，只不过它是Promise的实现版本

# JS的数据类型以及判断方式

![image-20210813193920894](面试.assets/image-20210813193920894.png)

# ==比较比较规则

- 类型相同直接比较
- 数字和字符串比较，将字符串转换成数字进行比较
- 其他类型和布尔值比较，将布尔转成数字
- undefined 和 null是一回事
- [10] == 10 true
- null == undefined true
- 0 == null false 
- 0 == {} false
- 0 == [] true
- 0 == '' true
- NaN和谁都不等
- 等下的情况都是转换成数字再做比较
- [] == false true  [] => ' ' => 0   false => 0
- ![] == false true   相当于 false == false
  -  把其他类型转换成布尔类型 ![] 准换成布尔类型再取反 
  - 转换成布尔类型的规律 只有**0 / NaN / null / undefined/ ' ' **五个是false其他都是true

# 样式继承

继承属性只有五大类（文本类型，字体类型，visitability、cursor属性、list-style属性）

# 完全二叉树

![image-20210817154608962](面试.assets/image-20210817154608962.png)

二叉树是非线性结构，其存储结构可以分为两种，即***\*顺序存储结构\****和***\*链式存储结构\****。

# vue2和vue3区别

## 1.vue3对全局API的优化

在 Vue3 中，全局和内部 API 都经过了重构，并考虑到了 tree-shaking 的支持。因此，全局 API现在只能作为 ES 模块构建的命名导出进行访问。

## 2.vue3优点

vue3支持vue2的大多数特性，实现对vue2的兼容

vue3对比vue2具有明显的性能提升

- 打包大小减少
- 初次渲染快，更新快
- 内存使用减少

vue3具有的composition API**实现逻辑模块化和重用**

增加了新特性，如Teleport组件，全局API的修改和优化等

## 3.响应式原理的不同

Vue2.x实现双向数据绑定原理，是通过es5的 Object.defineProperty，根据具体的key去读取和修改。其中的setter方法来实现数据劫持的，getter实现数据的修改。但是必须先知道想要拦截和修改的key是什么，所以vue2对于新增的属性无能为力，比如无法监听属性的添加和删除、数组索引和长度的变更，vue2的解决方法是使用Vue.set(object, propertyName, value) 等方法向嵌套对象添加响应式。

Vue3.x使用了ES2015的更快的原生proxy 替代 Object.defineProperty。Proxy可以理解成，在对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy可以直接监听对象而非属性，并返回一个新对象，具有更好的响应式支持

## 4.生命周期的不同

beforeCreate -> 请使用 setup()

created -> 请使用 setup()

beforeMount -> onBeforeMount

mounted -> onMounted

beforeUpdate -> onBeforeUpdate

updated -> onUpdated

beforeDestroy -> onBeforeUnmount

destroyed -> onUnmounted

errorCaptured -> onErrorCaptured

如果要想在页面中使用生命周期函数，以往vue2的操作是直接在页面中写入生命周期，而vue3是需要去引用的，这就是为什么3能够将代码压缩到更低的原因

## 5.默认项目目录结构的不同

vue3移除了配置文件目录，config 和 build 文件夹，移除了 static 文件夹，新增 public 文件夹，并且 index.html 移动到 public 中，在 src 文件夹中新增了 views 文件夹，用于分类视图组件和公共组件

# proxy和Reflect

`Reflect`对象的方法与`Proxy`对象的方法一一对应，只要是`Proxy`对象的方法，就能在`Reflect`对象上找到对应的方法。这就让`Proxy`对象可以方便地调用对应的`Reflect`方法，完成默认行为，作为修改行为的基础。也就是说，不管`Proxy`怎么修改默认行为，你总可以在`Reflect`上获取默认行为。

```js
const target = {
  name: 'yogln'
}
const p = new Proxy(target, {
  set: function (target, name, value, receiver) {
    var success = Reflect.set(target, name, value, receiver)
    console.log(success)
    if (success) {
      console.log('property ' + name + ' on ' + target + ' set to ' + value)
    }
    return success
  }
})
```

# Proxy实现响应式

Proxy本身就可以察觉到新增属性和对数组的原生方法的调用，所以无需额外的代码就可以实现响应式。但是对于深度监听（也就是嵌套对象的监听），我们是在 get 方法里递归调用了 reactive 方法。这里需要强调的是，和vue2使用Object.defineProperty不同，Object.defineProperty是在一上来遍历整个数据结构来实现深度监听，这里用Proxy是在get的时候（访问属性时）才动态的去深度监听，所以Proxy在深度监听性能更好

# websocket协议

WebSocket (WS)是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。WebSocket建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：

WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。

WSS（Web Socket Secure）是WebSocket的加密版

# compositionAPI原理

通过reactive的类型声明，我们可以看到函数接收一个类型为泛型T的参数，而这个泛型继承自object，故target的类型为object类或为其子类。返回类型将判断返回的对象是否继承自Ref对象，如果为否则可能为嵌套的Ref对象，需用递归解套。进入reactive函数内部，我们看到如果传入的对象为只读则返回对象本身，否则返回createReactiveObject，执行创建响应式对象。

在createReactiveObject函数中，会判断target对象是否为对象类型，如果不是则直接返回，开发模式下会在控制台打印警告。接着会判断目标是否已经为Proxy对象，是的话同样返回。通过以上检查后，代码会创建一个新的proxy对象来实现对象的响应式，proxy对象会根据对象的类型选择使用collectionHandlers还是baseHandlers。

# !DOCTYPE html 作用

 DOCTYPE标签是一种**标准通用标记语言的文档类型声明**，它的目的是要告诉**标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。**<!DOCTYPE> 声明必须是 HTML 文档的第一行，位于 标签之前。

# HTML、XML、XHTML 有什么区别

## html超文本标记语言

```
HTML 是用来描述和定义网页内容的标记语言，是构成网页的最基本的东西。
所谓超文本，就是说它除了能标记文本，还能标记其他的内容，比如：图片，链接，音频，视频等。
它的作用就是一个规范，告诉所有浏览器都统一标准，比如我给这段文字加个 <p> 标签，那就是告诉浏览器：这是一个段落。
我加个 <img> 标签：这是一张图片，别弄错了。浏览器看到后，就会正确解析，产生相应的行为。
```

## xml可扩展标记语言

```
它的表现形式就是给一个文档加一堆标签，说明每段文字是干什么的，有什么意义。
这样做的目的是方便存储、传输、分享数据，人和机器都可以很方便的阅读。
XML 和 HTML 有一个明显的区别就是：HTML 的标签都是预定义的，你不可以自己随便增加，比如你不能自造一个标签叫 <nihao>, 但是 XML 可以，你可以自己“发明”标签————这也是“可扩展的”一个含义
```

## xhtml可扩展超文本标记语言

```
XHTML 就是以 XML 的语法形式来写 HTML.
XHTML 出现的原因是：HTML 是一种语法形式比较松散的标记语言，语法要求也不严格。比如大小可以混用，属性值随便你加不加引号，单引号还是双引号也随便你，标签也可以不闭合。HTML 标准的制定者 W3C 一看这样下去不行，所谓无规矩不成方圆，所以就把 XML 的语法形式往 HTML 上一套，出现了 XHTML，所以你也可以把 XHTML 理解为 HTML 的严格语法形式，除此之外，其它方面基本一样。
比如 XHTML 有一些强制的要求，如下：

必须包含一个文件头声明 <!DOCTYPE>
所有元素名必须小写
所有空元素必须关闭
所有属性名必须小写
所有属性值必须加引号
所有布尔值属性必须加上属性值
```

# head里面的常用标签

## meta标签

### 1.name 属性

关键字属性（name="keywords"）

```
<meta name="keywords" content="汽车,汽车之家,汽车网,汽车报价,汽车图片,新闻,评测,社区,俱乐部">
```

描述信息（name="description"）

```
<meta name="description" content="一汽-大众品牌官网为您提供所有车型汽车价格、基本参数、内饰配置、安全科技、舒适科技等车型详情信息。">
```

### 2.http-equiv属性

相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。

```
<meta http-equiv="refresh" content="30; Url=http://www.baidu.com/"> <!--这是做了一个界面的跳转，表示30s不运行的话就跳转到指定的URL-->

<meta http-equiv="X-UA-Compatible" content="IE=Edge"> <!--这个是IE的浏览器生效的规则，如果你用的是谷歌，360等浏览器的话，这行规则不生效，如果你用的是IE浏览器的话，表示用IE最新的引擎去渲染HTML-->

<meta http-equiv="content-Type" charset=UTF8"><!--指定页面编码，我们称这种标签类型为自闭和标签，因为我们需要在标签的结尾写上“/”，为了方便我们识别标签类型
```

## title标签

## link标签

### 1.rel="icon"属性（图标）

该属性用于定义标签的图像（就是标签的标签前面的logo），后面的href是制定图标应该去那个URl查找。

```
 <link rel="icon" href="http://www.jd.com/favicon.ico">
```

### 2.rel="stylesheet"（渲染属性）

　　该属性是引用CSS文件对HTML的标签进行渲染，后面的href指定的css文件的路径（yinzhengjie.css文件应该和你的HTML放在一起才可以这样写哟）。

```
<link rel="stylesheet" href="yinzhengjie.css">
```

## script标签

该标签用于引用JavaScript文件

# 浏览器有几个线程

**浏览器内核是多线程**，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

- GUI 渲染线程
- JavaScript引擎线程
- 定时触发器线程
- 事件触发线程
- 异步http请求线程
  - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理

# PNG,JPG,GIF,WEBP的区别

png是便携式网络图片是一种`无损数据压缩位图文件格式`。优点是：压缩比高，色彩好。大多数地方都可以用。

`jpg`是一种`针对相片`使用的一种`失真压缩方法`，是一种`破坏性的压缩`，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。

gif是一种**位图文件**格式，以8位色重现真色彩的图像。可以实现动画效果。

webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。
缺点是压缩的时间更久了，兼容性不好，目前`谷歌和opera支持`。



# 动画

![image-20210818213916165](面试.assets/image-20210818213916165.png)

# 闭包

`内部函数的作用域链仍保持着对外部函数活动对象的引用，就是闭包。`

![image-20210818220129041](面试.assets/image-20210818220129041.png)

闭包的用途：

1. 计数器

   ```js
   function a() {
     let start = 0
     return funciton () {
       return start++
     }
   }
   let inc = a()
   inc() //0
   inc() //1
   inc() //2
   
   inc = null //释放当前变量，用完之后置空垃圾回收，防止内存泄漏
   ```

2. 闭包能够封装对象的私有属性和方法

   ```js
   function Person(name) {
     let age //私有属性
   
     //私有方法
     function setAge(value) {
       age = value
     }
     //私有方法
     function getAge() {
       return age
     }
     return {
       name,
       setAge,
       getAge
     }
   }
   
   let p = new Person('yogln')
   p.setAge(28)
   console.log(p.getAge())
   p = null // 释放当前变量
   ```

   闭包使得变量始终在内存中，内存消耗很大，滥用闭包可能造成内存泄漏，造成页面性能的问题，个别ie中使用置空也会总成内存泄漏

   闭包的表现形式

   ![image-20210831001711067](面试.assets/image-20210831001711067.png)

# em和rem vh和vw

- em相对父元素
- rem相对于根元素
- vh视口的高度
- vw视口的宽度

# object.defineproty

对对象的某个属性进行劫持，只能感知具体的对象属性，对新增属性和删除属性没法监听

对数组监听是进行索引值的监听，没办法监听新的值，对数组的方法进行了重写

![image-20210818230638568](面试.assets/image-20210818230638568.png)

# 居中的方式 

## 行内元素

水平居中：

1. text-align: center
2. width: fit-content; + margin: auto;

垂直居中：

1. line-height: xxxpx;

## 块级元素

水平居中：

1. margin: 0 auto;

水平垂直居中：

- 子绝父相，left：50%； top: 50%; 
  - 已知宽度 margin-top: 反向偏移 margin-left: 自身一半
  - 已知宽度 left: calc(50% - 宽度一半)；top: calc(50% - 宽度一半)
  - 未知宽度`定位+transform` left：50%； top: 50%; transform: translate(-50%, -50%)
- 绝对布局设置margin:auto;并设置top、left、right、bottom的值相等即可，不一定要都是0
- flex justify-content: center; /*使子项目水平居中*/  align-items: center; /*使子项目垂直居中*/
- 通过添加padding
- margin: 0 auto; 和translateY一起使用
- grid布局

其他居中方式

![image-20210828112938271](面试.assets/image-20210828112938271.png)

![image-20210828113352907](面试.assets/image-20210828113352907.png)

# display: none、visibility: hidden、opacity: 0三者区别

`opacity: 0`、`visibility: hidden`、`display: none`三者都是让对应的元素不可见，区别可以从结构、继承、性能三点上面来讲

#### 结构：

1. `display:none`: **会让元素完全从dom中消失**，渲染的时候不占据任何空间, **不能点击**
2. `visibility: hidden`:不会让元素从dom中消失，渲染元素继续占据空间，只是内容不可见，**不能点击**
3. `opacity: 0`: 不会让元素从dom中消失，渲染元素继续占据空间，只是内容不可见，**可以点击**

#### 继承：

1. `display: none`和`opacity: 0`：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。
2. `visibility: hidden`：是**继承属性**，子孙节点消失由于继承了`hidden`，通过设置`visibility: visible`;可以让子孙节点显式。

#### 性能：

1. `display:none` : 修改元素会造成文档重排,读屏器不会读取`display: none`元素内容，性能消耗较大
2. `visibility:hidden`: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取`visibility: hidden`元素内容
3. `opacity: 0` ： 修改元素会造成重绘，性能消耗较少

# 是先停止渲染还是先tcp挥手

先渲染页面，页面渲染完了再回挥手

# 32位和64位操作系统的区别



# 请说明数据库事务的特性，并描述脏读、不可重复读和幻读的现象

事务特性有：原子性、一致性、持久性、隔离性

脏读：就是没有提交的数据，举个例子：比如某个事务在对数据库中某条记录进行修改，修改后没有提交也没有回滚，也就是让其处于一个待定的状态，这个时候如果有其他的事务来先一步对这条记录进行读取或者处理了的现象。

不可重复读取：一个事务先后读取某条记录，但在两次读取之间该条记录被其他另一个事务给修改了，就造成了两次读取的数据不同的现象。

幻读：幻读就是一个事务按照查询条件查询以前检索过的数据，可是发现该数据被其他事务插入了满足其查询条件的新数据的现象。

不可重复读和脏读的区别是一个是读取了前一事务提交的数据，而一个是读取了另一个事务未提交的数据

# localStorage和sessionStorerage

**localStorage什么情况下会被清空？如何手动清空**

- 保存数据：localStorage.setItem(key,value); 
- 读取数据：localStorage.getItem(key); 
- 删除单个数据：localStorage.removeItem(key); 
- 删除所有数据：localStorage.clear(); 
- 得到某个索引的key：localStorage.key(index);

**SessionStorage什么情况下会被清空**？**如何手动清空**

>  SessionStorage：用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。

(关闭当前页面数据的销毁与否有两种情况：①如果它的页面中没有其他的超链接，或者没有打开，那么关闭当前页面，数据就会被销毁。②而如果通过当前这个页面，打开了其他的页面，那么只有当这些页面都关闭了，数据才会销毁。)

# position

- static，默认值。处于文档流的位置。 

- inherit，从父元素继承 position 属性的值。 

- fixed，生成绝对定位的元素。可定位于**相对于浏览器窗口**的指定坐标。但当祖先元素具有transform属性且不为none时，就会**相对于祖先元素**指定坐标，而不是浏览器窗口。 

- absolute，**相对于距该元素最近的已定位的祖先元素**进行定位。 

- relative，**相对于该元素在文档中的初始位置进行定位**。
- sticky: 针对出现滚动元素做定位,不脱离文档流，父元素离开页面时，在顶部有一种吸顶的效果，会跟随父元素一起离开

# align-item和align-content区别

[align-items](https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcss-flexbox-1%2F%23propdef-align-items)属性可以应用于所有的flex容器，它的作用是设置flex子项在每个flex行的交叉轴上的默认对齐方式。不同取值的效果如下所示：![image-20210821212608655](面试.assets/image-20210821212608655.png)

[align-content](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcss-flexbox-1%2F%23propdef-align-content)            **只适用**多行的flex容器（也就是flex容器中的子项不止一行时该属性才有效果），它的作用是当flex容器在交叉轴上有多余的空间时，将子项作为一个整体（属性值为：flex-start、flex-end、center时）进行对齐。

设置了`flex-wrap: wrap;`时，`align-content: center;`对单行的子项也有作用。

![image-20210821212629650](面试.assets/image-20210821212629650.png)

# 数组遍历终止

- forEach无法终止循环，return 也只能终止本次操作，进行下一次操作，可以通过trycatch抛出异常的方式终止

| 序号 |       方法        | break  |   continue   |    return    | return true  | return false | 结论 |
| :--: | :---------------: | :----: | :----------: | :----------: | :----------: | :----------: | :--: |
|  1   |     `for循环`     |  成功  | 跳出本次循环 |    不合法    |    不合法    |    不合法    |  √   |
|  2   | `Array.forEach()` | 不合法 |    不合法    | 跳出本次循环 | 跳出本次循环 | 跳出本次循环 |  ×   |
|  3   |    `for...in`     |  成功  | 跳出本次循环 |    不合法    |    不合法    |    不合法    |  √   |
|  4   |   `Array.map()`   | 不合法 |    不合法    | 跳出本次循环 | 跳出本次循环 | 跳出本次循环 |  ×   |
|  5   |  `Array.some()`   | 不合法 |    不合法    | 跳出本次循环 |     成功     | 跳出本次循环 |  √   |
|  6   |  `Array.every()`  | 不合法 |    不合法    |     成功     | 跳出本次循环 |     成功     |  √   |
|  7   | `Array.filter()`  | 不合法 |    不合法    | 跳出本次循环 | 跳出本次循环 | 跳出本次循环 |  ×   |

# css透明度之rgba和opacity

- opacity 属性能够设置的值从 0.0 到 1.0。值越小，越透明。
- rgba(red, green, blue, alpha)。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。

**区别**： opacity 可以影响字体以及红色小方块的透明度，而 rgba 不会。子元素会继承父元素的 opacity 属性

# HTTP2的缺点

HTTP2存在的问题

- 建立连接时间长 
  - 建立连接时间 = `1.5 RTT`
  - HTTPS 通信时间总和（基于TLS1.2） = TCP 建立连接时间 + TLS1.2 连接时间 + HTTP交易时间 = 1 RTT + 2 RTT + 1 RTT = 4 RTT
  - HTTPS 通信时间总和（基于TLS1.3） = TCP 建立连接时间 + TLS1.3 连接时间 + HTTP交易时间 = 1 RTT + 1 RTT + 1 RTT = 3 RTT

-  队头阻塞问题相较于 HTTP/1.1 更严重
  - 因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。
  - 因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

# http3为什么是UDP	

- 基于 TCP 开发的设备和协议非常多，兼容困难
- TCP 协议栈是 Linux 内部的重要部分，修改和升级成本很大
- UDP 本身是无连接的、没有建链和拆链成本
- UDP 的数据包无队头阻塞问题
- UDP 改造成本小

是基于UDP的QUIC协议

![image-20210823231132881](面试.assets/image-20210823231132881.png)

## 1. 多路复用，解决队头阻塞问题

QUIC 协议原生实现多路复用，是基于 UDP 协议实现的，同一个 QUIC 连接上可以创建多个 stream（数据流） 来发送多个 HTTP 请求，并且，多个 stream 之间没有依赖，传输的单个 stream可以保证有序交付且不会影响其他的数据流

并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。

## 2. 0RTT

通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。

**0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势**，这里面有两层含义:

- 传输层 0RTT 就能建立连接。
- 加密层 0RTT 就能建立加密连接

## 3.向前纠错机制

QUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还**包括了部分其他数据包的数据**，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。

**向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传**，因为数据重传将会消耗更多的时间（包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗）。

假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。

当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。

当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式

## 4. 加密认证的报文

TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。QUIC 大部分都是加密的

# 下拉刷新怎么做

# [Vue 数据更新了但页面没有更新的 7 种情况汇总及延伸总结](https://segmentfault.com/a/1190000022772025)

# display和visibility的区别

**空间占据**

`display: none;` 是彻底消失，不在文档流中占位，浏览器也不会解析该元素

`visibility:hidden;` 是视觉上消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素

`visibility:hidden`比`display:none`性能上要好，`display:none`切换显示时，页面产生回流，而`visibility`切换是否显示时则不会引起回流。

**元素继承**

`display:none` 不会被子元素继承，但是父元素都不在了，子元素自然也就不会显示了

`visibility:hidden` 会被子元素继承，可以通过设置子元素visibility:visible 使子元素显示出来

`opacity: 0` 也会被子元素继承，但是不能通过设置子元素opacity: 0使其重新显示

**事件绑定**

`display:none` 的元素都已经不再页面存在了，因此肯定也无法触发它上面绑定的事件；

`visibility:hidden` 元素上绑定的事件也无法触发；

`opacity: 0`元素上面绑定的事件是可以触发的。

**过渡动画**

`transition`对于`display` 肯定是无效的；

`transition`对于`visibility` 也是无效的；

`transition`对于`opacity` 是有效。

# vue转化为es5经历哪几个阶段

那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：

- 将代码字符串解析成抽象语法树，即所谓的 AST
- 对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码
- 根据处理后的 AST 再生成代码字符串

基于此，其实我们自己就可以实现一个简单的“编译器”，用于把 ES6 代码转成 ES5。

比如，可以使用 `@babel/parser` 的 `parse` 方法，将代码字符串解析成 AST；使用 `@babel/core` 的 `transformFromAstSync` 方法，对 AST 进行处理，将其转成 ES5 并生成相应的代码字符串；过程中，可能还需要使用 `@babel/traverse` 来获取依赖文件等。

# 浏览器对URL的长度限制

1. IE浏览器对URL的长度现限制为2048字节。
3. Firefox(Browser)对URL的长度限制为65536字节。
4. Safari(Browser)对URL的长度限制为80000字节。
5. Opera(Browser)对URL的长度限制为190000字节。
5. Google(chrome)对URL的长度限制为8182字节。

# ts的type和interface区别

一般来说，非对象类型，建议使用`type`，而对象类型`type`和`interface`都可以，那么我们怎们用呢？

```ts
interface IFoo {
  name: string
}

interface IFoo {
  age: 18
}

const foo: IFoo = {
  name: 'yogln',
  age: 18
}
```

可以看出`interface`可以重复定义属性和方法，而且定义的属性都被合并在了一起，但是`type`就不可以，而且`type`的别名是不可以重复的，这就是他们的区别

# 交换机和路由的区别

交换机工作于数据链路层，用来隔离冲突域，连接的所有设备同属于一个广播域（子网），负责子网内部通信。

路由器工作于网络层，用来隔离广播域（子网），连接的设备分属不同子网，工作范围是多个子网之间，负责网络与网络之间通信。

**工作层次不同：**

路由器工作在网络层（第三层）。

交换机主要工作在数据链路层（第二层）

**转发依据不同：**

路由转发所依据的对象是：IP地址。（网络地址）

交换机转发所依据的对象时：MAC地址。（物理地址）
**主要功能不同：**

路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。

交换机主要用于组建局域网，
交换机能做的，路由都能做。
交换机不能分割广播域，路由可以。
路由还可以提供防火墙的功能。
路由配置比交换机复杂

# WebSocket

浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道

## 有哪些优点

说到优点，这里的对比参照物是HTTP协议，概括地说就是：**支持双向通信，更灵活，更高效，可扩展性更好**

## 连接保持+心跳

WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。

但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。

- 发送方->接收方：ping
- 接收方->发送方：pong

ping、pong的操作，对应的是WebSocket的两个控制帧，`opcode`分别是`0x9`、`0xA`。

举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用`ws`模块）

前端定时发送心跳消息ping，后端收到ping类型的消息，立马返回pong消息，告知前端连接正常。如果一定时间没收到pong消息，就说明连接不正常，前端便会执行重连。

# iframe跨域

## No.1 document.domain+iframe跨域

`document.domain` 的方式实现跨域，适用场景仅在 **主域名相同，子级域名不同** 的情况下

- 两个页面设置相同的 `document.domain` ，共享Cookie
- 两个页面设置相同的 `document.domain` ，通过 `iframe` 实现两个页面的数据互通

#### 局限

- 首先，仅在主域名相同，子级域名不同的情况下
- 只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 数据无法通过这种方法共享

# 跨域携带cookie

前端需要在发送 XMLHttpRequest 的时候加上

```ini
xhr.withCredentials= true;
```

后端需要设置请求头（表示你信任 a.com 并允许 a.com 带上你的凭据）:

```ada
Access-Control-Allow-Origin: a.com //这里需要换成相应的发起请求的域名
Access-Control-Allow-Credentials: true
```

# 位操作符

- & 与运算 两个位都是 1 时，结果才为 1，否则为 0，如
       1 0 0 1 1 
  &  1 1 0 0 1 
  `------------------------------` 
      1 0 0 0 1 

- | 或运算 两个位都是 0 时，结果才为 0，否则为 1，如
       1 0 0 1 1 
  |   1 1 0 0 1 
  `------------------------------` 
    1 1 0 1 1 

- ^ 异或运算，两个位相同则为 0，不同则为 1，如
      1 0 0 1 1 
  ^  1 1 0 0 1 
  `-----------------------------` 
    0 1 0 1 0 

- ~ 取反运算，0 则变为 1，1 则变为 0，如
  ~   1 0 0 1 1 
  `-----------------------------` 
       0 1 1 0 0 

- << 左移运算，向左进行移位操作，高位丢弃，低位补 0，如

# flex布局设置最后一个元素靠右对齐

给父盒子开启弹性布局,然后给最后一个div加上`margin-left:auto`一个div靠左,

第一个div靠左只需给第一个div设置`margin-right:auto`即可.

**原因: margin-auto在flex布局的情况下,在水平方向上有空余空间的情况下，空余的空间会被平均分给水平方向上写有margin-left:auto属性的元素的外边距**

# 选择器+~>

**‘+’选择器则表示某元素后相邻的兄弟元素，也就是紧挨着的，是单个的。**

**而‘~’选择器则表示某元素后所有同级的指定元素，强调所有的。**

**'>' 只能选择作为某元素儿子元素的元素，不包括孙元素、曾孙元素等等等。**

# vue2的$set原理

1、如果是在开发环境，且target未定义（为null、undefined）或target为基础数据类型（string、boolean、number、symbol）时，抛出告警；

2、如果target为数组且key为有效的数组key时，将数组的长度设置为target.length和key中的最大的那一个，然后调用数组的splice方法（vue中重写的splice方法）添加元素；

3、如果属性key存在于target对象中且key不是Object.prototype上的属性时，表明这是在修改target对象属性key的值（不管target对象是否是响应式的，只要key存在于target对象中，就执行这一步逻辑），此时就直接将value直接赋值给target[key]；

4、判断target，当target为vue实例或根数据data对象时，在开发环境下抛错；

5、当一个数据为响应式时，vue会给该数据添加一个__ob__属性，因此可以通过判断target对象是否存在__ob__属性来判断target是否是响应式数据，当target是非响应式数据时，我们就按照普通对象添加属性的方式来处理；当target对象是响应式数据时，我们将target的属性key也设置为响应式并手动触发通知其属性值的更新；上面代码中最重要的就是如下代码：

```js
defineReactive(ob.value, key, val)
ob.dep.notify()
```

这两行是将新增属性设置为响应式，并手动触发通知该属性值的更新，这就是通过this.$set()设置之后新增的属性会变成响应式并及时体现在页面中的原因。

# CI和CD

CI/CD是两个独立过程的组合:**持续集成**和**持续部署**。下面列出了其中的主要步骤。

使用CI/CD管道，软件发布工件可以从代码提交阶段到测试、构建、部署和生产阶段在管道中移动和前进。这个概念非常强大，因为一旦指定了一个管道，它的一部分或全部就可以实现自动化，从而加快流程并减少错误

持续集成(CI)是构建软件并完成初始测试的过程。持续部署(CD)是将代码与基础设施结合起来的过程，确保完成所有测试并遵循策略，然后将代码部署到预期的环境中。当然，许多公司都有自己的流程，但主要步骤如下。

# 为什么要用 setTimeout 模拟 setInterval

## 推入任务队列后的时间不准确

在 `setInterval` 被推入任务队列时，如果在它前面有很多任务或者某个任务等待时间较长比如网络请求等，那么这个定时器的执行时间和我们预定它执行的时间可能并不一致

## 函数操作耗时过长导致的不准确

考虑极端情况，假如定时器里面的代码需要进行大量的计算(耗费时间较长)，或者是 `DOM` 操作。这样一来，花的时间就比较长，有可能前一 次代码还没有执行完，后一次代码就被添加到队列了。也会到时定时器变得不准确，甚至出现同一时间执行两次的情况。

`setInterval` 有两个缺点：

- 使用 `setInterval` 时，某些间隔会被跳过；
- 可能多个定时器会连续执行；

可以这么理解：**每个** `setTimeout` 产生的任务会直接 `push` 到任务队列中；而 `setInterval` 在每次把任务 `push` 到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中，如果有则不添加，没有则添加)。

因而我们一般用 `setTimeout` 模拟 `setInterval` ，来规避掉上面的缺点。

## setTimeout 模拟 setInterval

综上所述，在某些情况下，`setInterval` 缺点是很明显的，为了解决这些弊端，可以使用 `setTimeout()` 代替。

- 在前一个定时器执行完前，不会向队列插入新的定时器（解决缺点一）
- 保证定时器间隔（解决缺点二）

```js
function myInterval(fn, delay) {
  let timer = null
  function interval() {
    timer = setTimeout(() => {
      fn()
      interval()
    }, delay)
  }
  interval()
  return function () {
    clearTimeout(timer)
  }
} 
```

# 热更新原理

启动`webpack`，生成`compiler`实例。`compiler`上有很多方法，比如可以启动 `webpack` 所有**编译**工作，以及**监听**本地文件的变化。

使用`express`框架启动本地`server`，让浏览器可以请求本地的**静态资源**。

本地`server`启动之后，再去启动`websocket`服务，如果不了解`websocket`，建议简单了解一下[websocket速成](https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2017%2F05%2Fwebsocket.html)。通过`websocket`，可以建立本地服务和浏览器的双向通信

# Etag是怎么计算的

 ** `nginx` 中 `etag` 由响应头的 `Last-Modified` 与 `Content-Length` 表示为十六进制组合而成。**

Etag 是一个文件变换就要重新生成的一个值，如果用hash来计算达不到效率
不过http也没有明确指出它的计算方式吧
不过在nginx里面，是由Last-Modified和content-length的十六进制组合而成
这样想来是个Etag加强版本的Last-Modified，毕竟Last-Modified是个时间戳，只能精确到秒

# js原始数据类型和引用数据类型区别

1.原始数据类型包括：Number.String. Boolean. Null. Undefined.Symbol.BigInt
2.引用数据类型包括：对象. 数组. 函数
3.存储位置不同：

​		原始数据类型存储在栈中，占据空间小，大小固定，属于频繁使用数据。

​		引用数据类型存储在堆中，占据空间大，大小不固定。
4.传值方式不同：基本数据类型按值传递，无法改变一个基本数据类型的值。引用数据类型：按引用传递，引用类型值可改变。
5.1和Number(2)区别   1是基本数据类型，Number（1）是包装对象类型

# 什么情况会引起内存泄漏？

虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。

1. **意外的全局变量引起的内存泄漏。**

原因：全局变量，不会被回收。

解决：使用严格模式避免。

2.  **闭包引起的内存泄漏**

原因：闭包可以维持函数内局部变量，使其得不到释放。

解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。

3.  **没有清理的DOM元素引用**

原因：虽然别的地方删除了，但是对象中还存在对dom的引用

解决：手动删除。

4. **被遗忘的定时器或者回调**

原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。

解决：手动删除定时器和dom。

5. **子元素存在引用引起的内存泄漏**

原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。

解决：手动删除清空。

# 栈和堆的区别

## 一、堆栈空间分配区别：

1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的**栈**；

2、堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于**链表**。

## 二、堆栈缓存方式区别：

1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；

2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

## 三、堆栈数据结构区别:

1、栈（数据结构）：一种先进后出的数据结构。

2、堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

# 什么是执行上下文

执行上下文又叫做执行环境，js中通过栈执行上下文

执行上下文包含三个东西：变量对象VO、this、作用域链[[scope]]

接下来我们说下执行上下文（execution context），执行上下文是用于跟踪代码的运行情况，其特征如下：

1. 一段代码块对应一个执行上下文，被封装成函数的代码被视作一段代码块，或者“全局作用域”也被视作一段代码块。
2. 当程序运行，进入到某段代码块时，一个新的执行上下文被创建，并被放入一个 stack 中。当程序运行到这段代码块结尾后，对应的执行上下文被弹出 stack。
3. 当程序在某段代码块中运行到某个点需要转到了另一个代码块时（调用了另一个函数），那么当前的可执行上下文的状态会被置为挂起，然后生成一个新的可执行上下文放入 stack 的顶部。
4. stack 最顶部的可执行上下文被称为 running execution context。当顶部的可执行上下文被弹出后，上一个挂起的可执行上下文继续执行。

# document.ready和window.onload的区别

- document.ready方法在DOM树加载完成后就会执行，

- window.onload是在页面资源（比如图片和媒体资源，它们的加载速度远慢于DOM的加载速度）加载完成之后才执行。网页文档已经呈现出来，但由于网页数据还没有完全加载完毕，导致load事件不能够即时被触发

```js
window.onload=function(){
      //do something
}
//或者经常用到的图片
document.getElementById("imgID").onload=function(){
     //do something
} 
```

# node是单线程

“node是单线程的，它采用单线程异步非阻塞模式。它的单线程指的是自身Javascript运行环境的单线程，Node.js并没有给Javascript执行时创建新线程的能力，通过Libuv以及它的事件循环来实现异步。”

只是主线程是单线程，所有的网络请求或者异步任务都交给了内部的线程池去实现，本身只负责不断的往返调度，由事件循环不断驱动事件执行。

# node为什么支持高并发

1. 每个Node.js进程只有一个主线程在执行程序代码，形成一个**执行栈**（**execution context stack**)。
2. 主线程之外，还维护了一个"**事件队列**"（Event queue）。当用户的网络请求或者其它的异步操作到来时，node都会把它放到Event Queue之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。
3. 主线程代码执行完毕完成后，然后通过Event Loop，也就是**事件循环机制**，开始到Event Queue的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从**线程池**中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交EventLoop处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。
4. 主线程不断重复上面的第三步。

# 观察者模式和发布订阅模式的区别

观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。

![image-20210827001138610](面试.assets/image-20210827001138610.png)

从图中可以看出，观察者模式中观察者和目标直接进行交互，而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的

# V8

1. parser  解析器  生成AST抽象语法树

2. interpreter   解释器   Ignition   生成byteCode字节码  并直接执行

3. 清除AST 释放内存空间
4.  得到25% - 50%的等效机器代码大小
5.  compiler  运行过程中，解释器收集优化信息发送给编译器TurboFan
6.  重新生成机器码
7. 有些热点函数变更会由优化后的机器码还原成字节码 也就是deoptimization  回退字节码操作执行

优化点：

1. 值声明未调用，不会被解析生成AST
2. 函数只被调用一次，bytcode直接被解释执行，不会进入到编译优化阶段
3. 函数被调用多次，Igniton会收集函数类型信息，可能会被标记为热点函数，可能被编译成优化后的机器代码

好处：

1. 由于一开始不需要直接编译成机器码，生成了中间层的字节码，从而节约了时间
2. 优化编译阶段，不需要从源码重新解析,直接通过字节码进行优化，也可以deoptimization回退操作

```js
function sum(x,y){return x + y};
sum(1,2);
sum(3,4);
sum(5,6);
sum(7,8);//会回退字节码操作执行
```

# z-index什么时候才能起作用?

z-index只适用于已定位的元素：即拥有relative、absolute或者fixed的元素。所以z-index是一种依赖属性，依赖position属性。

# v-if和v-show的区别

### 区别：

v-if只有当指令的表达式返回值为true的时候才会被渲染，为false的时候，元素是不存在于文档中的；

而v-show则不管指令表达式的返回值是什么，都会被渲染，并且只是基于css的样式切换，元素始终存在于文档中。

### 什么时候用v-if？什么时候用v-show？

1.`v-if`在条件切换时，会对标签进行适当的创建和销毁，而`v-show`则仅在初始化时加载一次，因此`v-if`的开销相对来说会比`v-show`大。
2.`v-if`是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则`v-if`不会去渲染标签。`v-show`则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换

# 伪元素和伪类

![image-20210828140142765](面试.assets/image-20210828140142765.png)

# react的生命周期

​    1.初始化阶段（由ReactDOM.render()初次渲染）：{
​       constructor
​       componentWillMount
​       render
​       componentDidMount(初始化工作：网络请求、开启定时器、订阅消息)
​     }
​     2.更新阶段（setState和父组件render触发）：{
​       shouldComponentUpdate
​       componentWillUpdate
​       render
​       componentDidUpdate
​     }
​     3.卸载阶段（ReactDOM.unmountComponentAtNode触发）：{
​       componentWillUnmount(收尾工作：清除定时器、取消消息订阅)
​     }

# react父子传值

1、父组件给子组件传值直接在子组件的标签中 传入值，通过props获取

2、子组件给父组件传值父组件把修改值的函数传给子组件，子组件通过调用父组件的方法 将子组件的值传给父组件

3、兄弟组件之间传值

​	使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。

# 死锁

造成死锁必须达成的4个条件（原因）：

1. 互斥条件：一个资源每次只能被一个线程使用。
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系

# toFixed()

2.tofix()返回啥（语法错误），let a  = 2; 或者(2).toFixed()

# vue中的keep-alive

https://segmentfault.com/a/1190000020515898

1、`created`中初始化存储缓存的`cache`对象，和缓存的VNode的键的数组。`mounted`中监听黑白名单变动对缓存进行更新，获取`keep-alive`第一个子组件
2、根据`include exclude`名单进行匹配，决定是否缓存。如果不匹配，直接返回组件实例，如果匹配，到第3步
3、根据组件id和tag生成缓存组件的`key`，再去判断`cache`中是否存在这个key，即是否命中缓存，如果命中，用缓存中的实例替代vnode实例，然后更新`key`在`keys`中的位置，(LRU置换策略)。如果没有命中，就缓存下来，如果超出缓存最大数量`max`,删除`cache`中的第一项。
4、最后组件实例的keepAlive属性设置为true，这个在渲染和执行被包裹组件的钩子函数会用到，这里不详细说明。

关于开始提到的`abstract`属性，注意到官方文档中有这样一段关于`keep-alive`的描述

> <keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。

Vue在初始化生命周期的时候，为组件实例建立父子关系时会根据abstract属性决定是否忽略某个组件。在keep-alive中，设置了abstract:true，那Vue就会跳过该组件实例。

# 除了script还有什么可以跨域的标签

由于DOM中的src属性支持跨域,所以JSONP的原理也就是利用了script标签中的src来实现跨域的,除了script标签之外,还有img和link标签.

# git回档和修改commit

## **1.修改上一条提交的 commit message**

```undefined
git commit --amend
```

## **2. 修改之前提交的 commit message**

比如说，我想修改距此版本之前的第3条 commit message，运行

```undefined
git rebase -i HEAD~3
```

显示

```
pick 56b2308 feat(pages): home DONE
pick 82f65eb fix(pages movie): slides bug fixed
pick 08b2087 feat(pages home & movie): add FABs animation 
```

将要修改的那条 commit message，如 `pick 56b2308 feat(pages): home DONE`，`pick` 改为 `edit`，修改完成后保存退出。

然后运行

```undefined
git commit --amend
```

修改 commit message。

最后运行

```kotlin
git rebase --continue
```

完成。

# promise

```
const foo = async () => 1
console.log(foo().toString()) // object promise
const bar = Promise.resolve(1)
console.log(bar) //promise [[Prototype]]: Promise[[PromiseState]]: "fulfilled" [[PromiseResult]]: 1
```

# transition

transition 属性是一个简写属性，用于设置四个过渡属性：

| 值                                                           | 描述                                |
| :----------------------------------------------------------- | :---------------------------------- |
| [transition-property](https://www.w3school.com.cn/cssref/pr_transition-property.asp) | 规定设置过渡效果的 CSS 属性的名称。 |
| [transition-duration](https://www.w3school.com.cn/cssref/pr_transition-duration.asp) | 规定完成过渡效果需要多少秒或毫秒。  |
| [transition-timing-function](https://www.w3school.com.cn/cssref/pr_transition-timing-function.asp) | 规定速度效果的速度曲线。            |
| [transition-delay](https://www.w3school.com.cn/cssref/pr_transition-delay.asp) | 定义过渡效果何时开始。              |

```css
div
{
width:100px;
height:100px;
background:blue;
transition:width 2s;
}
div:hover
{
width:300px;
}

```

# animation 

| 值                                                           | 描述                                     |
| :----------------------------------------------------------- | :--------------------------------------- |
| *[animation-name](https://www.w3school.com.cn/cssref/pr_animation-name.asp)* | 规定需要绑定到选择器的 keyframe 名称。。 |
| *[animation-duration](https://www.w3school.com.cn/cssref/pr_animation-duration.asp)* | 规定完成动画所花费的时间，以秒或毫秒计。 |
| *[animation-timing-function](https://www.w3school.com.cn/cssref/pr_animation-timing-function.asp)* | 规定动画的速度曲线。                     |
| *[animation-delay](https://www.w3school.com.cn/cssref/pr_animation-delay.asp)* | 规定在动画开始之前的延迟。               |
| *[animation-iteration-count](https://www.w3school.com.cn/cssref/pr_animation-iteration-count.asp)* | 规定动画应该播放的次数。                 |
| *[animation-direction](https://www.w3school.com.cn/cssref/pr_animation-direction.asp)* | 规定是否应该轮流反向播放动画             |

```css
div
{
animation:mymove 5s infinite;
}
@keyframes mymove
{
from {left:0px;}
to {left:200px;}
}
```

# requestAnimationFrame

宏任务

`requestAnimationFrame`它不需要你去手动设置执行间隔时间，它是跟随系统的屏幕刷新频率走的，如果屏幕刷新频率是`60Hz`，那么它的执行间隔就是`16.7ms(1000/60≈16.7)`，如果屏幕刷新频率是`100Hz`，那么它的执行间隔就是`10ms(1000/100=10)`，这样就能够保证它的执行与屏幕的刷新频率保持一致，从而避免丢帧现象。

requestAnimationFrame的步伐跟着系统的刷新步伐走。**它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次**，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

#### requestAnimationFrame Vs setTimeout 区别

- `requestAnimationFrame`在窗口隐藏的时候，会暂停调用，而`setTimeout`不会暂停。
- `requestAnimationFrame`跟随系统屏幕刷新频率，而`setTimeout`手动配置，会存在丢帧现象

# Etag属性的缺点

不同操作系统，web服务器对于ETag的计算方法也不同，当使用不同操作系统，不同类型的web服务器做负载均衡的时候，如果用ETag作为判断条件，在被负载均衡到不同服务器后，则很容易导致缓存失效

# webpack打包原理

1. 定义 Compiler 类

2. 解析入口文件,获取 AST，使用@babel/parser来帮助我们分析内部的语法,包括 es6,返回一个 AST 抽象语法树。

3. 找出所有依赖模块 Babel 提供了@babel/traverse(遍历)方法维护这 AST 树的整体状态,我们这里使用它来帮我们找出依赖模块。

4. AST 转换为 code 将 AST 语法树转换为浏览器可执行代码

5. 递归解析所有依赖项,生成依赖关系图
6. 

# 对象判空

1. Object.keys(obj)
2. Reflect.ownKeys
3. for ... in 
4. if (JSON.stringify(data) === '{}') {    return false *// 如果为空,返回false* } return true *// 如果不为空，则会执行到这一步，返回true*

# redux原理

# 搞清clientHeight、offsetHeight、scrollHeight、offsetTop、scrollTop

https://blog.csdn.net/qq_35430000/article/details/80277587

# js操作dom如何进行增删改查

```js
// 增
// 1、创建元素 2、填充内容3、追加到已有元素中或body中
let addNew = document.createElement('p')
addNew.innerHTML = '我是新增的元素p'
con.appendChild(addNew)
let addNew2 = document.createElement('div')
addNew2.innerHTML = '我是直接追加在body中的'
document.body.appendChild(addNew2)

// 删
// 1、找需要删除的节点 2、需要删除节点父级 3、remove
pDom.removeChild(getDomById)

// 改
// 1、修改元素内容
getShowP.innerHTML = '我把原来内容改了'
// 2、修改元素样式
getShowP.style.color = '#f00'
// 3、插入内容(insertBefore())/替换replaceChild()
let addChildNew = document.createTextNode('子节点增加了内容')
getShowP.appendChild(addChildNew)
let reNew = document.createTextNode('我是来替换的')
pDom.replaceChild(reNew, getShowP)
//4、添加属性
let addAtr = document.createAttribute('class')
addAtr.value = 'setColor'
getTestDom.setAttributeNode(addAtr)
console.log(getTestDom.getAttribute('class')) // setColor
getTestDom.setAttribute('class', 'setFtSz') // 更改属性值 指定的属性已存在，则仅设置/更改值。
```

# 首页加载缓慢

1.将样式表放在首部-使用link标签将样式表放在文档的HEAD中

2.将脚本放在底部

3.使用字体图标（iconfont）

阿里矢量图标库。它只是往 HTML 里插入字符和 CSS 样式而已，和图片请求比起来资源占用完全不在一个数量级，如果你的项目里有小图标，就是用矢量图吧

4.解决办法1(路由懒加载)：把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，利用vue的异步组件和webpack的代码分割功能，实现路由组件的懒加载。

解决方法2(组件懒加载)：

```js
export default {
  components:{
    "One":resolve=>(['./one'],resolve)
  },  
}
```

5.使用免费 cdn 加载第三方资源

6.合并压缩js,css,减少请求次数以及减少流量的消耗

7.预加载是在浏览器空闲时请求将来可能会用到的页面内容(如图像、样式表和脚本)。使用这种方法，当用户要访问下一个页面时，页面中的内容大部分已经加载到缓存中了，因此可以大大改善访问速度。

# useEffect和componentdidmount有什么区别

useEffect是根据里面fn是异步的回调

componentdidmount里面是同步的回调

useLaoutEffect是同步回调

# setState是同步还是异步

![image-20210903231237874](面试.assets/image-20210903231237874.png)

legacy模式中，react中的批处理将多次的setState设置为一次更新，提高性能，将setstate放在settimeout中的执行中因为没有的上下文将会同步执行，但是在concurrent模式中的话，都是异步执行

# 防抖节流的应用常见

## 防抖

1. 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖

2. 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖

3. 文本编辑器实时保存，当无任何更改操作一秒后进行保存

   ```js
   function debounce (f, wait) {
     let timer
     return (...args) => {
       clearTimeout(timer)
       timer = setTimeout(() => {
         f(...args)
       }, wait)
     }
   }
   ```

## 节流

1. `scroll` 事件，每隔一秒计算一次位置信息等

2. 浏览器播放事件，每隔一秒计算一次进度信息等

3. input 框实时搜索并发送请求展示下拉列表，没隔一秒发送一次请求 (也可做防抖)

   ```js
    function throttle (f, wait) {
     let timer
     return (...args) => {
       if (timer) { return }
       timer = setTimeout(() => {
         f(...args)
         timer = null
       }, wait)
     }
   }
   ```

# webpack和vite对比

webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。 而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。 由于现代浏览器本身就支持ES Module，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。 由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。

当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。 在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。 当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。

另外，由于vite利用的是ES Module，因此在代码中不可以使用CommonJS

# react和vue的单项数据流

**React 采用单向数据绑定**

在 React 中，`View` 层是不能直接修改 `State`，必须通过相应的 `Actions` 来进行操作。

单向数绑定的优缺点：

优点：所有状态变化都可以被记录、跟踪，状态变化通过手动调用触发，源头易追溯。

缺点：会有很多类似的样板代码，代码量会相应的上升。

**Vue 支持单向数据绑定和双向数据绑定**

- 单向数据绑定：使用`v-bind`属性绑定、`v-on`事件绑定或插值形式`{{data}}`。
- 双向数据绑定：使用`v-model`指令，用户对`View`的更改会直接同步到`Model`。

Vue 的双向数据绑定就是指使用`v-model`指令进行数据绑定，而`v-model`本质上是`v-bind`和`v-on`相组合的语法糖，是框架自动帮我们实现了更新事件。换句话说，我们完全可以采取单向绑定，自己实现类似的双向数据绑定。

单向数绑定的优缺点：

优点：所有状态变化都可以被记录、跟踪，状态变化通过手动调用触发，源头易追溯。

缺点：会有很多类似的样板代码，代码量会相应的上升。

# meta标签设置viewport

- layout viewport就是一张大白纸，HTML的内容就写在这个大白纸上，

- visual viewport就是一个放大镜，上下左右移动，可以显示其中的一部分

  这个是浏览器给我们用的、能真正用来显示网页内容的区域，可以通过下面的js命令获取：

  ```javascript
  window.innerWidth
  window.innerHeight
  ```

- 个ideal viewport应该与手机屏幕大小的相同，确切来说，等于visual viewport的大小。把页面渲染到这个ideal viewport里面，就能在visual viewport中完美显示。

# meta标签

meta标签里面的内容，主要是提供关于这个HTML页面的元信息的。简单点说，就是你用这些信息来告诉浏览器，应该如何解析这个HTML文件。

```xml
<meta charset="utf-8">
```

除了上面这种简单的格式外，meta标签更常见的是这种`name + content`的形式：

```xml
<meta name="format-detection" content="telephone=no" />
```

所做的适配，就是要调整layout viewport的大小，而用meta标签就可以调整layout viewport的大小。上网去搜移动端适配，一定会看到下面这句代码：

```xml
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
```

先介绍一下这几个属性：

| 属性名            |                             说明                             |
| ----------------- | :----------------------------------------------------------: |
| width             | 设置layout viewport的宽度，为一个正整数，或字符串width-device |
| initial-scale     |         设置页面的初始缩放值，为一个数字，可以带小数         |
| minimum-scale     |         允许用户的最小缩放值，为一个数字，可以带小数         |
| maximum-scale     |         允许用户的最大缩放值，为一个数字，可以带小数         |
| height            | 设置layout viewport的高度，这个属性对我们并不重要，很少使用  |
| user-scalable     | 是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes代表允许 |
| target-densitydpi | 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个。安卓中支持，当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。 |

回到应用场景，我们用这个标签的主要目的是做移动端的适配，一般都是做一个专门为移动端设计的页面。所以，我们在设置layout viewport时，当然希望这个viewport的尺寸等于ideal viewport。

# requestIdleCallback

 它的原理是让浏览器在空闲的时候执行回调[函数](http://www.fly63.com/tag/函数)，而且在回调[函数](http://www.fly63.com/tag/函数)中通过参数告知预计还剩多少空闲时间。我们可以根据剩余的空闲时间来合理安排执行的任务量，确保不会影响其他高优先级任务的执行。

用法很简单： 

```
function doWork(deadline) {
  // 如果还有空闲时间，就继续执行doSomeTask
  while (deadline.timeRemaining() > 5) {
    doSomeTask();
  }
  // 否则，安排到下一次空闲时间执行
  requestIdleCallback(doWork)
}
...
requestIdleCallback(doWork)
```

有人会问，如果浏览器一直忙，岂不是没有机会执行后台任务？所以这个API提供了第二个参数timeout，它表示如果在timeout的时间间隔内callback都没有被调用，那么就像setTimeout那样，到超时时间将callback加入到事件队列中等待执行。[代码](http://www.fly63.com/tag/代码)如下：

```
function doWork(deadline) {
  // 如果还有空闲时间，或者到超时时间了，就继续执行任务直到做完
  while ((deadline.timeRemaining() > 5 || deadline.didTimeout) && tasks.length > 0) {
    doSomeTask();
  }
  // 否则，剩余的任务安排到下一次空闲时间执行
  if (tasks.length > 0) {
    requestIdleCallback(doWork)
  }
}
...
requestIdleCallback(doWork, 2000)
```

# js如何判断当前页面是否处于激活状态

**方式1：监听事件visibilitychange**

**方式2：监听事件blur和focus**

# 单点登录

### 同域名下的单点登录

`cookie`的`domain`属性设置为当前域的父域，并且父域的`cookie`会被子域所共享。`path`属性默认为`web`应用的上下文路径

利用 `Cookie` 的这个特点，没错，我们只需要将` Cookie `的` domain`属性设置为父域的域名（主域名），同时将 `Cookie `的` path `属性设置为根路径，将 `Session ID`（或 `Token`）保存到父域中。这样所有的子域应用就都可以访问到这个` Cookie`

不过这要求应用系统的域名需建立在一个共同的主域名之下，如 `tieba.baidu.com` 和 `map.baidu.com`，它们都建立在 `baidu.com `这个主域名之下，那么它们就可以通过这种方式来实现单点登录

### 不同域名下的单点登录(一)

如果是不同域的情况下，`Cookie`是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 `Web `服务

用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 `token` 写入 `Cookie`（注意这个 `Cookie `是认证中心的，应用系统是访问不到的）

应用系统检查当前请求有没有 `Token`，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心

由于这个操作会将认证中心的 `Cookie` 自动带过去，因此，认证中心能够根据 `Cookie` 知道用户是否已经登录过了

如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录

如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 `URL `，并在跳转前生成一个 `Token`，拼接在目标` URL` 的后面，回传给目标应用系统

应用系统拿到 `Token `之后，还需要向认证中心确认下 `Token` 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 `Token `写入` Cookie`，然后给本次访问放行。（注意这个 `Cookie` 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 `Token`，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了

此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法

### 不同域名下的单点登录(二)

可以选择将 `Session ID` （或 `Token` ）保存到浏览器的 `LocalStorage` 中，让前端在每次向后端发送请求时，主动将` LocalStorage `的数据传递给服务端

这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 `Session ID `（或 `Token `）放在响应体中传递给前端

单点登录完全可以在前端实现。前端拿到 `Session ID `（或 `Token` ）后，除了将它写入自己的 `LocalStorage` 中之外，还可以通过特殊手段将它写入多个其他域下的 `LocalStorage` 中

关键代码如下：

```javascript
// 获取 token
var token = result.data.token;
 
// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML
var iframe = document.createElement("iframe");
iframe.src = "http://app1.com/localstorage.html";
document.body.append(iframe);
// 使用postMessage()方法将token传递给iframe
setTimeout(function () {
    iframe.contentWindow.postMessage(token, "http://app1.com");
}, 4000);
setTimeout(function () {
    iframe.remove();
}, 6000);
 
// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage
window.addEventListener('message', function (event) {
    localStorage.setItem('token', event.data)
}, false);
```

前端通过 `iframe`+`postMessage()` 方式，将同一份 `Token` 写入到了多个域下的 `LocalStorage` 中，前端每次在向后端发送请求之前，都会主动从 `LocalStorage` 中读取` Token `并在请求中携带，这样就实现了同一份` Token` 被多个域所共享

此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域

# 插槽

普通的插槽在父组件中渲染，作用域插槽是在子组件中渲染

创建组件虚拟节点时，会将组件的儿子的虚拟节点保存起来。当初始化组件时,通过插槽属性将儿子进行分类 {a:[vnode],b[vnode]} 渲染组件时会拿对应的slot属性的节点进行替换操作。（插槽的作用域为父组件）

作用域插槽在解析的时候，不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此 函数进行渲染。（插槽的作用域为子组件）

# vue的template解析过程

https://segmentfault.com/a/1190000021436351

模板解析是Vue模板编译的第一步，即通过模板得到AST（抽象语法树）。

生成AST的过程核心就是借助HTML解析器，当HTML解析器通过正则匹配到不同的片段时会触发对应不同的钩子函数，通过钩子函数对匹配片段进行解析我们可以构建出不同的节点。

# 排序

![image-20210904172300413](面试.assets/image-20210904172300413.png)

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- **空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数

# 抽象类

调用接口时, 我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。 

但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法,，我们可以定义为抽象方法。 

 什么是抽象方法? 

- 在TypeScript中没有具体实现的方法(没有方法体)，就是抽象方法。
- 抽象方法，必须存在于抽象类中；抽象类是使用abstract声明的类；

 抽象类有如下的特点： 

- 抽象类是不能被实例的话（也就是不能通过new创建） 
- 抽象方法必须被子类实现，否则该类必须是一个抽象类；

多态值得是animal类的moving

# 继承的方式

https://segmentfault.com/a/1190000016708006

我了解的 js 中实现继承的几种方式有：

（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。

（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

# forof 和forin的区别

1. 推荐在循环对象属性的时候，使用`for...in`,在遍历数组的时候的时候使用`for...of`。
2. `for...in`循环出的是key，`for...of`循环出的是value
3. 注意，`for...of`是ES6新引入的特性。修复了ES5引入的`for...in`的不足
4. `for...of`不能循环普通的对象，需要通过和`Object.keys()`搭配使用

# useCallback和useMemo区别

https://segmentfault.com/a/1190000039405417

一句话：useCallback 缓存钩子函数，useMemo 缓存返回值（计算结果）。	

# CSS可继承属性

**1.字体系列属性**
font:组合字体
font-family:规定元素的字体系列
font-weight:设置字体的粗细
font-size:设置字体的尺寸
font-style:定义字体的风格
font-variant:偏大或偏小的字体
**2.文本系列属性**
text-indent:文本缩进
text-align:文本水平对刘
line-height:行高
word-spacing:增加或减少单词间的空白
letter-spacing：增加或减少字符间的空白
text-transform:控制文本大小写
direction:规定文本的书写方向
color:文本颜色
**3.元素可见性**
visibility
**4.表格布局属性**
caption-side定位表格标题位置
border-collapse合并表格边框
border-spacing设置相邻单元格的边框间的距离
empty-cells单元格的边框的出现与消失
table-layout表格的宽度由什么决定<automatic.fixed.inherit>
**5.列表布局属性**
list-style-type文字前面的小点点样式
list-style-position小点点位置
list-style以上的属性可通过这属性集合
**6.引用**
quotes设置嵌套引用的引号类型
**7.光标属性**
cursor:箭头可以变成需要的形状

# UDP和TCP的应用

![image-20210920152204091](面试.assets/image-20210920152204091.png)

# 函数组件和类组件的区别

https://segmentfault.com/a/1190000020861150

# 严格模式

设立"严格模式"的目的，主要有以下几个：

> 　　- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
>
> 　　- 消除代码运行的一些不安全之处，保证代码运行的安全；
>
> 　　- 提高编译器效率，增加运行速度；
>
> 　　- 为未来新版本的Javascript做好铺垫。

# eval

`eval()` 是一个危险的函数， 它使用与调用者相同的权限执行代码。如果你用 `eval()` 运行的字符串代码被恶意方（不怀好意的人）修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。

`eval()` 通常比其他替代方法更慢，因为它必须调用 JS 解释器，而许多其他结构则可被现代 JS 引擎进行优化。

此外，现代JavaScript解释器将javascript转换为机器代码。 这意味着任何变量命名的概念都会被删除。 因此，任意一个eval的使用都会强制浏览器进行冗长的变量名称查找，以确定变量在机器代码中的位置并设置其值。 另外，新内容将会通过 `eval()` 引进给变量， 比如更改该变量的类型，因此会强制浏览器重新执行所有已经生成的机器代码以进行补偿。 但是，（谢天谢地）存在一个非常好的eval替代方法：只需使用 [window.Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)。 这有个例子方便你了解如何将`eval()`的使用转变为`Function()`。
